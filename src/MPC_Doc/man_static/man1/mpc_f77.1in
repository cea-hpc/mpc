.\" Automatically generated by Pandoc 1.17.2
.\"
.TH "MPC Compilation wrappers" "1" "2020" "MPC-3.3.1" "Multi-Processor-Computing"
.hy
.SH NAME
.PP
mpc_cc, mpc_cxx, mpc_f77, mpc_f90, mpc_f08 \- MPI/OpenMP compilation
wrappers
.SH SYNOPSIS
.PP
\f[B]mpc_cc\f[] [options] \f[B]file...\f[]
.PP
\f[B]mpc_cxx\f[] [options] \f[B]file...\f[]
.PP
\f[B]mpc_ff77\f[] [options] \f[B]file...\f[]
.PP
\f[B]mpc_f90\f[] [options] \f[B]file...\f[]
.PP
\f[B]mpc_f08\f[] [options] \f[B]file...\f[]
.SH DESCRIPTION
.PP
The purpose of this wrapper is to provide to the user a convenient
manner to build MPI/OpenMP applications with a minimum effort.
All the flags required for the application to be linked to the libraries
are transparently provided by the wrapper.
The simplest invocation for a C code would be :
.IP
.nf
\f[C]
$\ mpc_cc\ my_mpi_code.c
\f[]
.fi
.SH OPTIONS
.PP
Here will be presented options allowed to be passed as argument to the
wrapper command.
All native options targeting the underlying compiler can be provided
transparently, any unkown options from MPC\[aq]s point of view is
discretly forwarded to the final compiler.
There is only one collision in option name, for the \f[B]\-\-help\f[],
which is caught by the wrapper to print its own help.
To avoid long output, the help from the underlying compiler is not
shown.
To display the native compiler help, please use
\f[B]\-\-compiler\-help\f[] instead.
Options are available for any language\-specific wrapper, only for few
exceptions, explicitly mentioned.
.TP
.B \f[B]\-h\f[], \f[B]\-\-help\f[]
Print the help / usage for this command.
.RS
.RE
.TP
.B \f[B]\-\-compiler\-help\f[]
Forward the actual help from the underlying compiler to the user
.RS
.RE
.TP
.B \f[B]\-v\f[], \f[B]\-\-version\f[]
Display the MPC version is wrapper is coming from.
.RS
.RE
.TP
.B \f[B]\-\-compilers\f[]
Display all compilers handled by the current installation.
As MPC can rely on a different compiler than the one used to build the
framework, an installation can handle multiple underlying compiler to
build an application.
the \f[B]\-\-compilers\f[] option will list all registered compilers for
the C language, in the order there are loaded by the wrapper.
The first one listed is picked as the default.
To change/add/remove compilers from this list, one can use the
\f[B]mpc_compiler_manager\f[] tool.
.RS
.RE
.TP
.B \f[B]\-\-show\f[]
Echoes every invocation to the underlying compiler instead of actually
running them (equivalent to a dry\-run).
Note that for MPC, a single wrapper invocation does \f[I]NOT\f[] map to
a single compiler invocation.
Because some other tasks have to be performed beforehand, this command
will display every invocation leading to build the final binary.
To have a partial view and/ord retrieve only subsets of the compilafion
flags, it could be better to look for the \f[B]\-\-showme\f[] option.
.RS
.RE
.TP
.B \f[B]\-\-showme:\f[]\f[I]token\f[]
Depending on \f[I]token\f[], displays the arguments supplied to the
underlying compiler.
The following values for \f[I]token\f[] are accepted:
.RS
.IP \[bu] 2
\f[I]compile\f[] : displays compilation flags for a translation unit to
be built.
.IP \[bu] 2
\f[I]link\f[]: displays linking flags for the programm to be assembled.
.IP \[bu] 2
\f[I]command\f[]: displays the absolute path to the underlying compiler.
This last value is equivalent to what \f[B]mpc_compiler_manager\f[] is
able to do.
.RE
.TP
.B \f[B]\-\-use:\f[]\f[I]token\f[]
Depending on \f[I]token\f[], invoke the supplied compiler with only a
subset of arguments.
The following values for \f[I]token\f[] are accepted: \-
\f[I]command\f[]: call the underlying compiler without any implicit
arguments.
User can provide its own argument list.
.RS
.RE
.TP
.B \f[B]\-cc=\f[]\f[I]compiler\f[]
Force the compilation wrapper to use the designated compiler instead of
the default one.
This may be convenient to punctually override the compiler management,
avoiding the pain to change the default compiler back and forth.
Even if the option mention \[aq]cc\[aq], it can be used for any
language, like C++ and Fortran.
.RS
.RE
.TP
.B \f[B]\-fmpc\-privatize\f[], \f[B]\-fnompc\-privatize\f[]
The privatization is steered by the use of the flag
\f[B]\-fmpc\-privatize\f[].
It will make the application compatible with a thread\-based MPI usage,
by privatizing every global/static variables, changing their scope to
have different copies for each MPI \[aq]process\[aq] (becoming threads
in a thread\-based context).
This flag will enable compilation optimisations, but does not limit the
application to be run in thread\-base mode only.
the \f[B]\-\-fnompc\-privatize\f[] only as an \[aq]explicit\[aq]
interest.
If specified multiples times, only the last occurence prevails.
.RS
.RE
.TP
.B \f[B]\-fmpc\-tlsopt\f[], \f[B]\-fnompc\-tlsopt\f[]
Because global/variables are translated into multi\-level TLS variables
(ExTLS), the overhead is higher.
To reduce this overhead, the same methodoly used for pthread TLS
variables is applied to \[aq]ExTLS\[aq] variables.
Multiple approaches exist to access a TLS variable, depending the DSO it
is coming from, the number of access in an instruction subset, etc.
These approaches can be split into 2 main categories: by using a
function call OR by using a process register (the 32\-bit GS register in
that case).
As the use of such register can be an issue in some situations, the
\f[B]\-fnompc\-tlsopt\f[] option indicates that only TLS optimizations
through function calls are allowed.
\f[B]\-fmpc\-tlsopt\f[] is implied by default and only used to be
explicit.
.RS
.RE
.TP
.B \f[B]\-fmpc\-plugin\f[], \f[B]\-fnompc\-plugin\f[] [ \f[B]\f[I]C only\f[]\f[] ]
Global and TLS variables have some similarities but are also quite
different.
One ont them is the way they can be initialized before the program
starts.
FOr example, such code below is allowed for global/static variable but
clearly forbidden when initializing a TLS variables (ExTLS or not) :
Because the value of \f[I]b\f[] cannot be determined statically (as
\f[I]a\f[] is a TLS too and the value became dynamic), the C standard
fordids the dynamic initialiation of variables before the call to the
main() function \-\- while it is permitted in C++.
As this code can be valid with global variables, the thread\-based
approach and the privatization of global variables cannot be limited by
that.
MPC provies a plugin to create such a dynamic initialization when
necessary.
the \f[B]\-fnompc\-plugin\f[] explicitly disable such plugin, which
might be useful in some situations.
the \f[B]\-fmpc\-plugin\f[] is implied by default for C code only and is
provided for clarity.
.RS
.IP
.nf
\f[C]
int\ a\ =\ 2;
int\ &b\ =\ &a;
\f[]
.fi
.RE
.TP
.B \f[B]\-fmpc\-include\f[], \f[B]\-fnompc\-include\f[] [ \f[B]\f[I]C/C++ only\f[]\f[] ]
Force the inclusion of \f[I]mpc_main.h\f[] to the binary.
This header contains some macro redefinition to help replacing symbols
of the targeted application.
The approach of running MPI main() codes require the catch such function
and running it in threads.
The purpose of such header is to rename the \f[C]main()\f[] symbol in
\f[C]mpc_user_main__()\f[] to avoid the program to be sticked to it (as
the main() is one of the only symbols which cannot be preloaded, for
safety reasons).
This is only a C/C++ option, the approach is different in Fortran, based
on a rewrite of the symbol afterwards, through the
\f[C]objcopy\ \\\-\\\-redefine\-sym\f[] tool.
.RS
.RE
.TP
.B \f[B]\-fopenmp\f[], \f[B]\-fnoopenmp\f[]
Enable of disable the support of OpenMP pragma directives.
As the OpenMP semantics needs to be enlarged for MPC purposes
(threadprivate variables need to be promoted for instance), is option is
caught by the wrapper before being forwared to the underlying compiler.
Furthermore, depending on the vendor (GCC, Intel) the proper option is
set (\-fopenmp vs \-openmp) without requiring any modification from the
command\-line.
.RS
.RE
.TP
.B \f[B]\-\-target=\f[]\f[I]target\f[]
Specifies the target the compilation is for.
The list of valid target available for the current installation is
available by using the \f[B]\-\-target_list\f[] option.
.RS
.RE
.TP
.B \f[B]\-\-target\-list\f[]
List currently active MPC target, for cross\-compilation only.
.RS
.RE
.SH AUTHORS
Julien Adam <adamj@paratools.com>.
