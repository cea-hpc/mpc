#!/usr/bin/env python
import json
import sys
import argparse
import os
import string

scriptpath = os.path.dirname(os.path.realpath(sys.argv[0]))

'''
Argument Parsing
'''

argparser = argparse.ArgumentParser(
    description='This is the MPC fortran Module Generator')

argparser.add_argument('-m', '--mpih', action='store',
                       help='Path to the \'mpi.h\' header file to be preprocessed')

args = argparser.parse_args()

if (args.mpih is None):
    print("ERROR Missing argument see '" +
          os.path.basename(sys.argv[0]) + " -h'")

'''
Load Knowledge Bases
'''

# ALL MPI function footprints
with open(scriptpath + '/mpi_interface.json') as data_file:
    mpi_interface = json.load(data_file)

# The C to Fortran data-type conversion table
with open(scriptpath + '/typesc2f.json') as data_file:
    typesc2f = json.load(data_file)

# Load current MPC constants from the output of the "gen_iface.c" file
with open('./constants.json') as data_file:
    mpcconstants = json.load(data_file)

# Load sizeofs definitions
with open(scriptpath + '/sizeofs.json') as data_file:
    sizeofs = json.load(data_file)

# Get the preprocessed MPI.h from the MPC compiler
parsed_mpih = ""

try:
    with open(args.mpih) as data_file:
        parsed_mpih = data_file.read()
except IOError:
    print("Could not preparse the", args.mpih, "Header")


def MPIFunctionsisPresentinMPC(fname):
    # Note that we implement all MPI_File functions which are in ROMIO
    # We have to do this as the ROMIO header is only compiled later on
    # if fname.find("MPI_File") != -1:
    #    return 1
    index = parsed_mpih.find(fname)
    if index < 0:
        return 0
    else:
        return 1


module_file_data = ""


"""
 Write Copyright HEADER
"""


def genheader():
    return ('! ############################# MPC License ############################## \n'
            '! # Wed Nov 19 15:19:19 CET 2008                                         # \n'
            '! # Copyright or (C) or Copr. Commissariat a l\'Energie Atomique          # \n'
            '! #                                                                      # \n'
            '! # IDDN.FR.001.230040.000.S.P.2007.000.10000                            # \n'
            '! # This file is part of the MPC Runtime.                                # \n'
            '! #                                                                      # \n'
            '! # This software is governed by the CeCILL-C license under French law   # \n'
            '! # and abiding by the rules of distribution of free software.  You can  # \n'
            '! # use, modify and/ or redistribute the software under the terms of     # \n'
            '! # the CeCILL-C license as circulated by CEA, CNRS and INRIA at the     # \n'
            '! # following URL http://www.cecill.info.                                # \n'
            '! #                                                                      # \n'
            '! # The fact that you are presently reading this means that you have     # \n'
            '! # had knowledge of the CeCILL-C license and that you accept its        # \n'
            '! # terms.                                                               # \n'
            '! #                                                                      # \n'
            '! # Authors:                                                             # \n'
            '! #   - BESNARD Jean-Baptiste jbbesnard@paratools.fr                     # \n'
            '! #   - AUTOGENERATED by genmod.py                                       # \n'
            '! #                                                                      # \n'
            '! ######################################################################## \n'
            '\n'
            '! /!\ DO NOT EDIT THIS FILE IS AUTOGENERATED BY modulegen.py\n'
            '\n')

#
#  THIS IS mpif.h
#
#


print("\n#################################")
print("Generating the mpif.h Header File")
print("#################################\n")


def genConstantsFromMPC(genmpif=0):
    ret = ""
    print("Processing MPC constants...")
    for const in mpcconstants:
        # Skip the last empty elem */
        if const.get("name") == None:
            continue
        name = const["name"]
        decl = const["decl"]
        ismpif = const["mpif_only"]

        # process the mpif part only if enabled
        if ismpif and (genmpif == 0):
            continue

        print("\tGEN\t" + name + "...")
        ret += decl
    return ret


module_file_data = genheader()

module_file_data += genConstantsFromMPC(1)

"""
 Open Output header FILE
"""

f = open("mpif.h", "w")

f.write(module_file_data)

f.close()


#
#
#  THIS IS THE CONSTANT FORTRAN MODULE
#
#
print("\n#######################################")
print("Generating the CONSTANTS Fortran Module")
print("#######################################\n")

module_file_data = genheader()


"""
 Write Module START
"""

module_file_data += ("MODULE MPI_CONSTANTS\n"
                     "IMPLICIT NONE\n\n")

"""
 Write Constant data-types
"""


module_file_data += genConstantsFromMPC()

module_file_data += "\n\n"

module_file_data += (
    'TYPE :: MPI_Status\n'
    '       INTEGER :: MPI_SOURCE, MPI_TAG, MPI_ERROR\n'
    '       INTEGER :: count_lo\n'
    '       INTEGER :: count_hi_and_cancelled\n'
    'END TYPE MPI_Status\n\n')


const_types = ["MPI_Comm", "MPI_Datatype", "MPI_Group", "MPI_Win", "MPI_File",
               "MPI_Op", "MPI_Errhandler", "MPI_Request", "MPI_Message", "MPI_Info"]

for t in const_types:
    module_file_data += ('TYPE :: ' + t + '\n'
                         '       INTEGER :: VAL\n'
                         'END TYPE ' + t + '\n\n')


#
# HERE WE ARE DONE WITH THE CONSTANT MODULE FILE
#

module_file_data += "END MODULE MPI_CONSTANTS\n"


"""
 Open Output Module FILE
"""

f = open("mpi_constants.f90", "w")

f.write(module_file_data)

f.close()


#
#
#  THIS IS THE BASE FORTRAN MODULE
#
#

print("\n##################################")
print("Generating the BASE Fortran Module")
print("##################################\n")


module_file_data = genheader()


"""
 Write Module START
"""

module_file_data += ("MODULE MPI_BASE\n"
                     "IMPLICIT NONE\n\n")


"""
Common DECL
"""

module_file_data += "\n\nINTERFACE\n\n"


module_file_data += ('\n'
                     'SUBROUTINE MPI_INIT(ierror)\n'
                     '       INTEGER ierror\n'
                     'END SUBROUTINE MPI_INIT\n'
                     '\n'
                     'SUBROUTINE MPI_INIT_THREAD(v0,v1,ierror)\n'
                     '       INTEGER v0, v1, ierror\n'
                     'END SUBROUTINE MPI_INIT_THREAD\n'
                     '\n'
                     'FUNCTION MPI_WTIME()\n'
                     '       DOUBLE PRECISION MPI_WTIME\n'
                     'END FUNCTION MPI_WTIME\n'
                     '\n'
                     'FUNCTION MPI_WTICK()\n'
                     '       DOUBLE PRECISION MPI_WTICK\n'
                     'END FUNCTION MPI_WTICK\n'
                     '\n'
                     'FUNCTION PMPI_WTIME()\n'
                     '       DOUBLE PRECISION PMPI_WTIME\n'
                     'END FUNCTION PMPI_WTIME\n'
                     '\n'
                     'FUNCTION PMPI_WTICK()\n'
                     '       DOUBLE PRECISION PMPI_WTICK\n'
                     'END FUNCTION PMPI_WTICK\n'
                     '\n'
                     'SUBROUTINE MPI_NULL_DELETE_FN(COMM, KEYVAL, ATTRIBUTE_VAL,&\n'
                     '       EXTRA_STATE, IERROR)\n'
                     '       USE MPI_CONSTANTS,ONLY: MPI_ADDRESS_KIND\n'
                     '       INTEGER COMM, KEYVAL, IERROR\n'
                     '       INTEGER(KIND=MPI_ADDRESS_KIND) ATTRIBUTE_VAL, EXTRA_STATE\n'
                     'END SUBROUTINE MPI_NULL_DELETE_FN\n'
                     '\n'
                     'SUBROUTINE MPI_DUP_FN(OLDCOMM, KEYVAL, EXTRA_STATE,&\n'
                     '       ATTRIBUTE_VAL_IN, ATTRIBUTE_VAL_OUT, FLAG, IERROR)\n'
                     '       USE MPI_CONSTANTS,ONLY: MPI_ADDRESS_KIND\n'
                     '       INTEGER OLDCOMM, KEYVAL, IERROR\n'
                     '       INTEGER(KIND=MPI_ADDRESS_KIND) EXTRA_STATE, ATTRIBUTE_VAL_IN, ATTRIBUTE_VAL_OUT\n'
                     '       LOGICAL FLAG\n'
                     'END SUBROUTINE MPI_DUP_FN\n'
                     '\n'
                     'SUBROUTINE MPI_NULL_COPY_FN(OLDCOMM, KEYVAL, EXTRA_STATE,&\n'
                     '       ATTRIBUTE_VAL_IN, ATTRIBUTE_VAL_OUT, FLAG, IERROR)\n'
                     '       USE MPI_CONSTANTS,ONLY: MPI_ADDRESS_KIND\n'
                     '       INTEGER OLDCOMM, KEYVAL, IERROR\n'
                     '       INTEGER(KIND=MPI_ADDRESS_KIND) EXTRA_STATE, ATTRIBUTE_VAL_IN, ATTRIBUTE_VAL_OUT\n'
                     '       LOGICAL FLAG\n'
                     'END SUBROUTINE MPI_NULL_COPY_FN\n'
                     '\n'
                     'SUBROUTINE MPI_COMM_NULL_DELETE_FN(COMM, COMM_KEYVAL, ATTRIBUTE_VAL,&\n'
                     '       EXTRA_STATE, IERROR)\n'
                     '       USE MPI_CONSTANTS,ONLY: MPI_ADDRESS_KIND\n'
                     '       INTEGER COMM, COMM_KEYVAL, IERROR\n'
                     '       INTEGER(KIND=MPI_ADDRESS_KIND) ATTRIBUTE_VAL, EXTRA_STATE\n'
                     'END SUBROUTINE MPI_COMM_NULL_DELETE_FN\n'
                     '\n'
                     'SUBROUTINE MPI_COMM_DUP_FN(OLDCOMM, COMM_KEYVAL, EXTRA_STATE,&\n'
                     '       ATTRIBUTE_VAL_IN, ATTRIBUTE_VAL_OUT, FLAG, IERROR)\n'
                     '       USE MPI_CONSTANTS,ONLY: MPI_ADDRESS_KIND\n'
                     '       INTEGER OLDCOMM, COMM_KEYVAL, IERROR\n'
                     '       INTEGER(KIND=MPI_ADDRESS_KIND) EXTRA_STATE, ATTRIBUTE_VAL_IN, ATTRIBUTE_VAL_OUT\n'
                     '       LOGICAL FLAG\n'
                     'END SUBROUTINE MPI_COMM_DUP_FN\n'
                     '\n'
                     'SUBROUTINE MPI_COMM_NULL_COPY_FN(OLDCOMM, COMM_KEYVAL, EXTRA_STATE,&\n'
                     '       ATTRIBUTE_VAL_IN, ATTRIBUTE_VAL_OUT, FLAG, IERROR)\n'
                     '       USE MPI_CONSTANTS,ONLY: MPI_ADDRESS_KIND\n'
                     '       INTEGER OLDCOMM, COMM_KEYVAL, IERROR\n'
                     '       INTEGER(KIND=MPI_ADDRESS_KIND) EXTRA_STATE, ATTRIBUTE_VAL_IN, ATTRIBUTE_VAL_OUT\n'
                     '       LOGICAL FLAG\n'
                     'END SUBROUTINE MPI_COMM_NULL_COPY_FN\n'
                     '\n'
                     'SUBROUTINE MPI_TYPE_NULL_DELETE_FN(DATATYPE, TYPE_KEYVAL, ATTRIBUTE_VAL,&\n'
                     '       EXTRA_STATE, IERROR)\n'
                     '       USE MPI_CONSTANTS,ONLY: MPI_ADDRESS_KIND\n'
                     '       INTEGER DATATYPE, TYPE_KEYVAL, IERROR\n'
                     '       INTEGER(KIND=MPI_ADDRESS_KIND) ATTRIBUTE_VAL, EXTRA_STATE\n'
                     'END SUBROUTINE MPI_TYPE_NULL_DELETE_FN\n'
                     '\n'
                     'SUBROUTINE MPI_TYPE_DUP_FN(OLDTYPE, TYPE_KEYVAL, EXTRA_STATE,&\n'
                     '       ATTRIBUTE_VAL_IN, ATTRIBUTE_VAL_OUT, FLAG, IERROR)\n'
                     '       USE MPI_CONSTANTS,ONLY: MPI_ADDRESS_KIND\n'
                     '       INTEGER OLDTYPE, TYPE_KEYVAL, IERROR\n'
                     '       INTEGER(KIND=MPI_ADDRESS_KIND) EXTRA_STATE, ATTRIBUTE_VAL_IN, ATTRIBUTE_VAL_OUT\n'
                     '       LOGICAL FLAG\n'
                     'END SUBROUTINE MPI_TYPE_DUP_FN\n'
                     '\n'
                     'SUBROUTINE MPI_TYPE_NULL_COPY_FN(OLDTYPE, TYPE_KEYVAL, EXTRA_STATE,&\n'
                     '       ATTRIBUTE_VAL_IN, ATTRIBUTE_VAL_OUT, FLAG, IERROR)\n'
                     '       USE MPI_CONSTANTS,ONLY: MPI_ADDRESS_KIND\n'
                     '       INTEGER OLDTYPE, TYPE_KEYVAL, IERROR\n'
                     '       INTEGER(KIND=MPI_ADDRESS_KIND) EXTRA_STATE, ATTRIBUTE_VAL_IN, ATTRIBUTE_VAL_OUT\n'
                     '       LOGICAL FLAG\n'
                     'END SUBROUTINE MPI_TYPE_NULL_COPY_FN\n'
                     '\n'
                     'SUBROUTINE MPI_WIN_NULL_DELETE_FN(WIN, WIN_KEYVAL, ATTRIBUTE_VAL,&\n'
                     '       EXTRA_STATE, IERROR)\n'
                     '       USE MPI_CONSTANTS,ONLY: MPI_ADDRESS_KIND\n'
                     '       INTEGER WIN, WIN_KEYVAL, IERROR\n'
                     '       INTEGER(KIND=MPI_ADDRESS_KIND) ATTRIBUTE_VAL, EXTRA_STATE\n'
                     'END SUBROUTINE MPI_WIN_NULL_DELETE_FN\n'
                     '\n'
                     'SUBROUTINE MPI_WIN_DUP_FN(OLDWIN, WIN_KEYVAL, EXTRA_STATE,&\n'
                     '       ATTRIBUTE_VAL_IN, ATTRIBUTE_VAL_OUT, FLAG, IERROR)\n'
                     '       USE MPI_CONSTANTS,ONLY: MPI_ADDRESS_KIND\n'
                     '       INTEGER OLDWIN, WIN_KEYVAL, IERROR\n'
                     '       INTEGER(KIND=MPI_ADDRESS_KIND) EXTRA_STATE, ATTRIBUTE_VAL_IN, ATTRIBUTE_VAL_OUT\n'
                     '       LOGICAL FLAG\n'
                     'END SUBROUTINE MPI_WIN_DUP_FN\n'
                     '\n'
                     'SUBROUTINE MPI_WIN_NULL_COPY_FN(OLDWIN, WIN_KEYVAL, EXTRA_STATE,&\n'
                     '       ATTRIBUTE_VAL_IN, ATTRIBUTE_VAL_OUT, FLAG, IERROR)\n'
                     '       USE MPI_CONSTANTS,ONLY: MPI_ADDRESS_KIND\n'
                     '       INTEGER OLDWIN, WIN_KEYVAL, IERROR\n'
                     '       INTEGER(KIND=MPI_ADDRESS_KIND) EXTRA_STATE, ATTRIBUTE_VAL_IN, ATTRIBUTE_VAL_OUT\n'
                     '       LOGICAL FLAG\n'
                     'END SUBROUTINE MPI_WIN_NULL_COPY_FN\n'
                     )


"""
 Write Interface
"""


print("Processing MPI Functions\n")


for f in mpi_interface:
    functionName = f
    capsfunctioname = f.upper()

    names = []
    types = []
    wasprefixed = []

    uses = []

    # check for presence inside MPC
    if MPIFunctionsisPresentinMPC(functionName) == 0:
        continue
    else:
        print("\tGEN\t" + functionName + "...")

    # Add the error flag
    if type(mpi_interface[functionName]) == type([]):
        mpi_interface[functionName].append(["int", "ierror"])

    contains_void_arg = 0

    for arg in mpi_interface[functionName]:
        name = arg[1]
        ctype = arg[0]
        ftype = typesc2f.get(ctype)

        if ftype == None:
            # Type can't be converted to Fortran ABORT
            ftype = "NONE"
            print("\t ERROR failed to translate :",
                  ctype + " " + name + "==> " + ftype)
            exit(1)

        if ftype == "EXTERNAL":
            contains_void_arg = 1
            break

        # If we are here we managed to do the type translation

        # Make sure the name is not a prefix in the type
        if "!!VAR!!" in ftype:
            ftype = ftype.replace("!!VAR!!", name)
            wasprefixed.append(1)
        else:
            wasprefixed.append(0)

        types.append(ftype)
        names.append(name)

        # Check for constants
        if "MPI_ADDRESS_KIND" in ftype:
            uses.append("MPI_ADDRESS_KIND")
        if "MPI_COUNT_KIND" in ftype:
            uses.append("MPI_COUNT_KIND")
        if "MPI_STATUS_SIZE" in ftype:
            uses.append("MPI_STATUS_SIZE")
        if "MPI_OFFSET_KIND" in ftype:
            uses.append("MPI_OFFSET_KIND")

    # Do not generate functions with void pointers in F90
    if contains_void_arg:
        continue

    # Emit the subroutine code
    module_file_data += "\n\nSUBROUTINE " + capsfunctioname + "("
    # FUCTION FOOTPRINT
    for i in range(0, len(names)):
        module_file_data += names[i]
        if i < (len(names) - 1):
            module_file_data += ","
            if (((i+1) % 3) == 0) and (i):
                module_file_data += "&\n   "
    module_file_data += ")\n"
    # USE CONSTANTS IF NEEDED
    # Hacky way to get unique elements
    uses = list(set(uses))
    if len(uses):
        string_uses = ""
        for i in range(0, len(uses)):
            string_uses += uses[i]
            if i < (len(uses) - 1):
                string_uses += ","
        module_file_data += "   USE MPI_CONSTANTS,ONLY: " + string_uses + "\n"

    # DUMP ARGS
    if len(names) != len(types) or len(types) != len(wasprefixed):
        print("SOMETHING WENT WRONG with argument manipulation in " +
              functionName + " ==> " + names + types)

    for i in range(0, len(names)):
        if wasprefixed[i]:
            module_file_data += "   " + types[i] + "\n"
        else:
            module_file_data += "   " + types[i] + "\t" + names[i] + "\n"

    module_file_data += "END SUBROUTINE " + capsfunctioname + "\n"

module_file_data += "\n\nEND INTERFACE\n\n"

"""
 Write Module END
"""

module_file_data += "END MODULE MPI_BASE\n"


"""
 Open Output Module FILE
"""

f = open("mpi_base.f90", "w")

f.write(module_file_data)

f.close()

#
#
#  THIS IS THE SIZEOF FORTRAN MODULE
#
#

print("\n################################")
print("Generating the SIZEOF Fortran Module")
print("################################\n")

module_file_data = genheader()


"""
 Write Module START
"""

module_file_data += ("MODULE MPI_SIZEOFS\n"
                     "IMPLICIT NONE\n\n")


module_file_data += ("PUBLIC :: MPI_SIZEOF\n"
                     "INTERFACE MPI_SIZEOF\n\n")

cnt = 0

for s in sizeofs:
    module_file_data += "MODULE PROCEDURE MPI_SIZEOF_" + str(cnt) + "\n"
    cnt += 1

module_file_data += ("\nEND INTERFACE ! MPI_SIZEOF\n\n")
module_file_data += ("CONTAINS\n")

cnt = 0

for s in sizeofs:
    module_file_data += "\nSUBROUTINE MPI_SIZEOF_" + \
        str(cnt) + "( X, SIZE, RES )\n"
    module_file_data += s[0].upper() + "\n"
    module_file_data += "INTEGER SIZE, RES\n"
    module_file_data += "RES=0\n"
    module_file_data += "SIZE=" + str(s[1]) + "\n"
    module_file_data += "END SUBROUTINE MPI_SIZEOF_" + str(cnt) + "\n"
    cnt += 1

"""
 Write Module END
"""

module_file_data += "\nEND MODULE MPI_SIZEOFS\n"

"""
 Open Output Module FILE
"""

f = open("mpi_sizeofs.f90", "w")

f.write(module_file_data)

f.close()

#
#
#  THIS IS THE MPI FORTRAN MODULE
#
#

print("\n################################")
print("Generating the MPI Fortran Module")
print("################################\n")


module_file_data = genheader()


"""
 Write Module START
"""

module_file_data += ("MODULE MPI\n\n")


module_file_data += "USE MPI_BASE\n"
module_file_data += "USE MPI_CONSTANTS\n"
module_file_data += "USE MPI_SIZEOFS\n"


"""
 Write Module END
"""

module_file_data += "\nEND MODULE MPI\n"


"""
 Open Output Module FILE
"""

f = open("mpi.f90", "w")

f.write(module_file_data)

f.close()


#
#
#  THIS IS THE MPIF08 FORTRAN MODULE GENERATOR
#
#


# Load MPI Types definitions
with open(scriptpath + '/MPIf08_types.json') as data_file:
    f08types = json.load(data_file)


# Load MPI to C Types definitions
with open(scriptpath + '/MPIf08_ctypes.json') as data_file:
    f08ctypes = json.load(data_file)

#
#
#  THIS IS THE MPIF08 CTYPE MODULE
#
#


def mpiToC(mpiname):
    return mpiname.replace("MPI_", "c_")


print("\n######################################")
print("Generating the F08 CTypes  Fortran Module")
print("########################################\n")

module_file_data = genheader()


"""
 Write Module START
"""

module_file_data += "module mpi_f08_ctypes\n"
module_file_data += "\n"
module_file_data += "! If you want to extend this file, extend MPIf08_ctype.json\n"
module_file_data += "\n"
module_file_data += "use,intrinsic :: iso_c_binding\n"
module_file_data += "\n"
module_file_data += "\n"

for mpitype, ctype in f08ctypes.items():
    module_file_data += "integer, parameter :: " + \
        mpiToC(mpitype) + " = " + ctype + "\n"


# GENERATE C MPI STATUS
module_file_data += "\n"
module_file_data += "!If you ever need to change this STATUS edit genmod.py\n"

module_file_data += ('type, bind(c) :: c_Status\n'
                     '   integer(c_int)  :: MPI_SOURCE\n'
                     '   integer(c_int)  :: MPI_TAG\n'
                     '   integer(c_int)  :: MPI_ERROR\n'
                     '   integer(c_int)  :: cancelled\n'
                     '   integer(c_intptr_t)  :: size\n'
                     'end type c_Status')

module_file_data += "\n"
module_file_data += "\n"
module_file_data += "end module mpi_f08_ctypes\n"


"""
 Open Output Module FILE
"""

f = open("mpi_f08_ctypes.f90", "w")

f.write(module_file_data)

f.close()

#
#
#  THIS IS THE MPIF08 TYPE MODULE
#
#


print("\n######################################")
print("Generating the F08 Types  Fortran Module")
print("########################################\n")

module_file_data = genheader()


"""
 Write Module START
"""

module_file_data += "module mpi_f08_types\n"
module_file_data += "\n"
module_file_data += "! If you want to extend this file, extend MPIf08_type.json\n"
module_file_data += "\n"
module_file_data += "use,intrinsic :: iso_c_binding\n"
module_file_data += "use :: mpi_f08_ctypes\n"
module_file_data += "private :: c_Count, c_Status\n"
module_file_data += "\n"
module_file_data += "\n"

#
# GENERATE Type descriptions
#

for mpitype in f08types:
    # Walk all the f08 MPI TYPES

    # Skip the last empty elem
    if mpitype.get("name") == None:
        continue

    name = mpitype["name"]

    print("Generating types for " + name)

    if mpitype.get("layout") == None:
        print("(W) It seems that " + str(name) + "has no layout")
        continue

    layout = mpitype["layout"]

    # Emit Type
    module_file_data += "type, bind(C) :: " + name + "\n"

    for target_entry in layout:
        # Emit Content
        ttype = target_entry["type"]
        tname = target_entry["name"]

        if ttype == "int":
            module_file_data += "    integer :: " + tname + "\n"
        elif ttype == "func":
            module_file_data += "    type(c_ptr) :: " + tname + "\n"
        elif ttype == "ptr":
            module_file_data += "    integer*8 :: " + tname + "\n"
        elif ttype == "long":
            module_file_data += "    integer*8 :: " + tname + "\n"
        # Done emmiting content

    module_file_data += "end type " + name + "\n"
    module_file_data += "\n"
    # DONE Walking all the f08 MPI TYPES

#
# Generate Operator CODE
#


def operatorSuffix(operator):
    if operator == "==":
        return "equal"
    elif operator == "=":
        return "assign"
    elif operator == "/=":
        return "notequal"
    else:
        print("(E) No such OPERATOR " + operator)
        exit(1)


def operatorAggregator(operator):
    if operator == "==":
        return ".AND."
    elif operator == "/=":
        return ".OR."
    elif operator == "=":
        return ""
    else:
        print("(E) No such OPERATOR " + operator)
        exit(1)


def operatorAggregatorROOT(operator):
    if operator == "=":
        return ""
    if operator == "==":
        return ".TRUE."
    elif operator == "/=":
        return ".FALSE."
    else:
        print("(E) No such OPERATOR " + operator)
        exit(1)


def genOperatorC(mpi_type, operator, rev=0):
    ret = ""

    fname_ext = operatorSuffix(operator)
    aggreg = operatorAggregator(operator)
    aggregROOT = operatorAggregatorROOT(operator)
    name = mpi_type["name"]

    if name.find("_function") != -1:
        return "!SKIP function ptr\n"

    if name == "MPI_Status":
        ckind = mpiToC(name)
    else:
        ckind = f08ctypes.get(name)

    if ckind == None:
        return "!FAIL no such kind " + name + "\n"

    layout = mpi_type["layout"]

    if rev == 1:
        if operator == "=":
            ret += "subroutine " + name + "_" + fname_ext + "_cr( a , b)\n"
        else:
            ret += "function " + name + "_" + \
                fname_ext + "_cr( a , b) result(r)\n"
        aintent = "in"
        if operator == "=":
            aintent = "out"
        if name == "MPI_Status":
            ret += "   type(" + ckind + "), intent("+aintent+") ::  a \n"
        else:
            ret += "   integer(" + ckind + "), intent("+aintent+") ::  a \n"
        ret += "   type(" + name + "), intent(in) ::  b \n"
    else:
        if operator == "=":
            ret += "subroutine " + name + "_" + fname_ext + "_c( a , b)\n"
            ret += "   type(" + name + "), intent(out) ::  a \n"
        else:
            ret += "function " + name + "_" + \
                fname_ext + "_c( a , b) result(r)\n"
            ret += "   type(" + name + "), intent(in) ::  a \n"
        if name == "MPI_Status":
            ret += "   type(" + ckind + "), intent(in) ::  b \n"
        else:
            ret += "   integer(" + ckind + "), intent(in) ::  b \n"

    if operator != "=":
        ret += "   logical :: r\n"
        ret += "   r = ( " + aggregROOT + " "
        for target_entry in layout:
            # No operators for c_ptr
            if target_entry["type"] == "func":
                continue
            # Emit Equal
            tname = target_entry["name"]
            if name == "MPI_Status":
                ret += " " + aggreg + \
                    " ( a%" + tname + " " + operator + "  b%" + tname + "  )&\n "
            else:
                if rev == 1:
                    ret += " " + aggreg + \
                        " ( a " + operator + "  b%" + tname + " )&\n "
                else:
                    ret += " " + aggreg + \
                        " ( a%" + tname + " " + operator + "  b  )&\n "
        ret += ")\n"
    else:
        for target_entry in layout:
            # No operators for c_ptr
            if target_entry["type"] == "func":
                continue
            # Emit Equal
            tname = target_entry["name"]
            if name == "MPI_Status":
                ret += "   a%" + tname + " =  b%" + tname + "\n"
            else:
                if rev == 1:
                    ret += "   a =  b%" + tname + "\n"
                else:
                    ret += "   a%" + tname + " =  b\n"

    if rev == 1:
        if operator == "=":
            ret += "end subroutine " + name + "_" + fname_ext + "_cr\n"
        else:
            ret += "end function " + name + "_" + fname_ext + "_cr\n"
    else:
        if operator == "=":
            ret += "end subroutine " + name + "_" + fname_ext + "_c\n"
        else:
            ret += "end function " + name + "_" + fname_ext + "_c\n"

    ret += "\n"

    return ret


def genOperator(mpi_type, operator):
    ret = ""

    fname_ext = operatorSuffix(operator)
    aggreg = operatorAggregator(operator)
    aggregROOT = operatorAggregatorROOT(operator)

    name = mpi_type["name"]
    layout = mpi_type["layout"]

    if operator == "=":
        ret += "subroutine " + name + "_" + fname_ext + "( a , b)\n"
        ret += "   type(" + name + "), intent(out) ::  a\n"
    else:
        ret += "function " + name + "_" + fname_ext + "( a , b) result(r)\n"
        ret += "   type(" + name + "), intent(in) ::  a\n"

    ret += "   type(" + name + "), intent(in) ::  b\n"

    if operator != "=":
        ret += "   logical :: r\n"
        ret += "   r = ( " + aggregROOT + " "
        for target_entry in layout:
            # No operators for c_ptr
            if target_entry["type"] == "func":
                continue
            # Emit Equal
            tname = target_entry["name"]
            ret += " " + aggreg + \
                " ( a%" + tname + " " + operator + "  b%" + tname + "  )&\n "
        ret += ")\n"
    else:
        for target_entry in layout:
            # No operators for c_ptr
            if target_entry["type"] == "func":
                continue
            # Emit Equal
            tname = target_entry["name"]
            ret += "   a%" + tname + " =  b%" + tname + "\n"

    if operator == "=":
        ret += "end subroutine " + name + "_" + fname_ext + "\n"
    else:
        ret += "end function " + name + "_" + fname_ext + "\n"

    ret += "\n"

    return ret

#
# Generate == Operator DECLS
#


def genOperatorDecls(operator):
    ret = "\n"
    if operator == "=":
        ret += "interface assignment(=)\n"
    else:
        ret += "interface operator(" + operator + ")\n"

    suffix = operatorSuffix(operator)

    for mpitype in f08types:
        # Walk all the f08 MPI TYPES

        # Skip the last empty elem
        if mpitype.get("name") == None:
            continue

        for target_entry in mpitype["layout"]:
            # No operators for c_ptr
            if target_entry["type"] == "func":
                continue

        name = mpitype["name"]

        ret += "   module procedure " + name + "_" + suffix + "\n"
        if f08ctypes.get(name) != None or name == "MPI_Status":
            ret += "   module procedure " + name + "_" + suffix + "_c\n"
            ret += "   module procedure " + name + "_" + suffix + "_cr\n"
        # DONE Walking all the f08 MPI TYPES

    ret += "end interface\n"

    ret += "\n"

    for mpitype in f08types:
        # Walk all the f08 MPI TYPES

        # Skip the last empty elem
        if mpitype.get("name") == None:
            continue

        name = mpitype["name"]

        ret += "private :: " + name + "_" + suffix + "\n"
        if f08ctypes.get(name) != None:
            ret += "private :: " + name + "_" + suffix + "_c\n"
        # DONE Walking all the f08 MPI TYPES

    ret += "\n"
    return ret

#
# OPERATOR DECL GEN
#


module_file_data += genOperatorDecls("==")
module_file_data += genOperatorDecls("/=")
module_file_data += genOperatorDecls("=")

#
# OPERATOR GEN
#

module_file_data += "\n"
module_file_data += "contains\n"
module_file_data += "\n"

for mpitype in f08types:
    module_file_data += genOperator(mpitype, "==")
    module_file_data += genOperatorC(mpitype, "==")
    module_file_data += genOperatorC(mpitype, "==", 1)
    module_file_data += genOperator(mpitype, "/=")
    module_file_data += genOperatorC(mpitype, "/=")
    module_file_data += genOperatorC(mpitype, "/=", 1)
    module_file_data += genOperator(mpitype, "=")
    module_file_data += genOperatorC(mpitype, "=")
    module_file_data += genOperatorC(mpitype, "=", 1)

module_file_data += "\n"
module_file_data += "\n"
module_file_data += "end module mpi_f08_types\n"


"""
 Open Output Module FILE
"""

f = open("mpi_f08_types.f90", "w")

f.write(module_file_data)

f.close()

#
#
#  THIS IS THE MPIF08 CONSTANT MODULE
#
#

print("\n#########################################")
print("Generating the F08 Contants  Fortran Module")
print("###########################################\n")

module_file_data = genheader()


"""
 Write Module START
"""

module_file_data += "module mpi_f08_constants\n"
module_file_data += "\n"
module_file_data += "\n"
module_file_data += "   use,intrinsic :: iso_c_binding\n"
module_file_data += "use :: mpi_f08_ctypes\n"
module_file_data += "use :: mpi_f08_types\n"
module_file_data += "\n"
module_file_data += "\n"

# Emit ignore

module_file_data += "	type(MPI_Status), bind(C, name=\"mpc_f08_status_ignore\"), target :: MPI_STATUS_IGNORE\n"
module_file_data += "	type(MPI_Status), dimension(1), bind(C, name=\"mpc_f08_statuses_ignore\"), target :: MPI_STATUSES_IGNORE\n"

# Walk all the f08 constants
for const in mpcconstants:
        # Skip the last empty elem */
    if const.get("name") == None:
        continue
    name = const["name"]
    decl = const["decl"]
    ismpif = const["mpif_only"]
    # Skip constants with no type
    if const.get("type") == None:
        continue
    # Skip constants with no value
    if const.get("value") == None:
        print("(W) It seems that " + str(name) + "has a type but no value ?")
        continue
    ftype = const["type"]
    fval = const["value"]
    # Skip F77 Procedures
    if ismpif:
        continue 
    # HANDLE LINK TIME VALUES
    if name == "MPI_COMM_WORLD":
        module_file_data += "	type(MPI_Comm), dimension(1), bind(C, name=\"mpc_f08_world\"), target :: MPI_COMM_WORLD\n"
    elif name == "MPI_COMM_SELF":
        module_file_data += "	type(MPI_Comm), dimension(1), bind(C, name=\"mpc_f08_self\"), target :: MPI_COMM_SELF\n"
    elif name == "MPI_COMM_NULL":
        module_file_data += "	type(MPI_Comm), dimension(1), bind(C, name=\"mpc_f08_null\"), target :: MPI_COMM_NULL\n"
    elif name == "MPI_IN_PLACE":
        module_file_data += "	integer(c_int), bind(C, name=\"mpc_f08_in_place\"), target :: MPI_IN_PLACE\n"
    elif ftype == "int":
        module_file_data += "	integer, parameter :: " + \
            name + " = " + str(fval) + "\n"
    elif ftype == "long":
        module_file_data += "	integer*8, parameter :: " + \
            name + " = " + str(fval) + "\n"
    elif (ftype.find("MPI_") != -1):
        module_file_data += "	type(" + ftype + ") :: " + \
            name + " = " + ftype + "(" + str(fval) + ")\n"
    else:
        module_file_data += "!ERR No such type conversion defined to " + ftype + "\n"
# Done Walking F08 constants


module_file_data += "\n"
module_file_data += "\n"
module_file_data += "end module mpi_f08_constants\n"


"""
 Open Output Module FILE
"""

f = open("mpi_f08_constants.f90", "w")

f.write(module_file_data)

f.close()

#
#
#  THIS IS THE MPIF08 C INTERFACE MODULE
#
#


def genCallArgs(argArray, ierror=0, fortranskip=1, pointer_args=0):
    ret = "( "
    length = len(argArray)
    # Is there an errror flag to skip
    if ierror == 0:
        for i in range(0, length):
            arg = argArray[i]
            if arg[1] == "ierror":
                length = length - 1

    for i in range(0, length):
        arg = argArray[i]
        atype = arg[0]
        if len(arg) >= 3:
            intent = arg[2]
        else:
            intent = "notset"

        if pointer_args and intent == "in" and (atype.count("*") == 0):
            add = "*"
            print("ADD")
        else:
            add = ""

        ret += add + arg[1]
        if i < (length - 1):
            if fortranskip == 1:
                ret += ",&\n"
            else:
                ret += ",\n"
    ret += ")"
    return ret


print("\n############################################")
print("Generating the F08 C Interface  Fortran Module")
print("##############################################\n")

module_file_data = genheader()


"""
 Write Module START
"""

module_file_data += "module mpi_f08_c\n"
module_file_data += "\n"
module_file_data += "\n"
module_file_data += "use,intrinsic :: iso_c_binding\n"
module_file_data += "implicit none\n"
module_file_data += "\n"
module_file_data += "interface\n"
module_file_data += "\n"


def getIntentforArg(arg):
    #
    # Intent
    #
    ret = ""
    if (arg[0].find("MPI_Status") == -1) and (arg[0] != "void*"):
        if (2 < len(arg)):
            intent = arg[2]
            if intent == "in":
                ret = ", intent(in)"
            elif intent == "out":
                ret = ", intent(out)"
            elif intent == "inout":
                ret = ", intent(inout)"
            else:
                ret = "ERROR"

    return ret


def genCTypesforArg(args, suffix="", transtyping=0, doval=0, flat_ptr=0):
    ret = ""
    for arg in args:
        cname = arg[1]
        value = ""
        if arg[0].find("*"):
            value = ", value"
        ctype = f08ctypes.get(arg[0].replace("*", ""))
        cintent = ""
        carray = ""

        #
        # TYPING
        #

        # Handle the case of assumed size when using
        # this function to genereate trans-typing constructs
        assumed_size = 0
        if (flat_ptr == 1) and (arg[0].find("[]") != -1) and arg[0] != "MPI_Request[]":
            # Translate to integer width
            #value = ""
            ctype = "type(c_ptr)"
        else:
            if arg[0] == "MPI_Status*" or arg[0] == "MPI_Status[]":
                value = ""
                ctype = "type(c_Status)"
                if arg[0] == "MPI_Status[]":
                    ctype += ", target "
                    carray = "(" + arg[3] + ")"
            elif arg[0] == "void*":
                ctype = "type(*), dimension(..)"
                assumed_size = 1
                value = ""
            elif arg[0] == "MPI_Request*":
                value = ""
                ctype = "integer(c_int)"
            elif arg[0] == "MPI_Request":
                ctype = "integer(c_int)"
            elif arg[0].find("_function") != -1:
                value = ""
                if transtyping:
                    ctype = "type(c_ptr)"
                else:
                    ctype = "type(c_ptr), value "
            elif arg[0] == "int[][3]":
                value = ""
                ctype = "integer(c_int), target "
                if len(arg) != 4:
                    ctype = "ARRERR " + arg[0]
                else:
                    carray = "(3," + arg[3] + "), target "
                    #assumed_size = 1
            elif ctype != None:
                ctype = "integer(" + ctype + ")"
            elif (arg[0].find("[]") != -1) or arg[0] == "char*":  # Array case
                value = ""
                if arg[0] == "char*":
                    ctype = "character(kind=c_char)"
                    carray = "(*)"
                    assumed_size = 1
                elif len(arg) != 4:
                    ctype = "ARRERR " + arg[0]
                else:
                    arr_ctype = f08ctypes.get(arg[0].replace("[]", ""))
                    if arg[0] == "MPI_Request[]":
                        arr_ctype = "c_int"
                    if arr_ctype != None:
                        arr_len = arg[3]
                        ctype = "integer(" + arr_ctype + "), target "
                        carray = "(" + arg[3] + ")"
                        if arg[3] == "*":
                            carray = "(8192)"
                    else:
                        ctype = "ARR " + arg[0]
            else:
                ctype = "FAIL(" + arg[0] + ")"
        # DONE TYPING
        #
        # Intent
        #
        if transtyping == 0:
            cintent = getIntentforArg(arg)
        # OUT variables are not passed by value
        # ierror is passed by address
        if (cintent.find("out") != -1) or (doval == 0) or (cname == "ierror"):
            value = ""

        if (flat_ptr == 1) and (arg[0].find("[]") != -1):
            cintent = ""

        # Here we skip assumed sizes for transtyping
        if assumed_size and transtyping:
            continue

        ret += ctype + value + cintent + " :: " + cname + suffix + carray
        ret += "     !" + arg[0] + " " + arg[1] + "\n"
    # DONE WALKING ARGS
    return ret


for mpi_func, args in mpi_interface.items():

    if MPIFunctionsisPresentinMPC(mpi_func) == 0:
        module_file_data += "\n"
        module_file_data += "! " + mpi_func + " NOT IMPLEMENTED in MPC\n"
        module_file_data += "\n"
        continue

    if (mpi_func.find("_c2f") != -1):
        continue

    module_file_data += "\n"
    module_file_data += "\n"

    c_func = mpi_func + "_c"
    module_file_data += "function " + c_func
    module_file_data += genCallArgs(args, 1) + "&\n"
    module_file_data += "bind(C, name=\"" + \
        mpi_func.lower() + "_f08\") result(ret)\n"
    module_file_data += "\n"
    module_file_data += "use, intrinsic :: iso_c_binding\n"
    module_file_data += "use :: mpi_f08_constants\n"
    module_file_data += "use :: mpi_f08_ctypes\n"
    module_file_data += "implicit none\n"
    module_file_data += "\n"

    module_file_data += genCTypesforArg(args, "", 0, 1, 1)

    module_file_data += "integer(c_int) :: ret ! dummy\n"

    # DONE WALKING ARGS
    module_file_data += "\n"
    module_file_data += "end function " + c_func + "\n"
# DONE WALKING FUNCS

module_file_data += "\n"
module_file_data += "end interface\n"
module_file_data += "\n"
module_file_data += "end module mpi_f08_c\n"


"""
 Open Output Module FILE
"""

f = open("mpi_f08_c.f90", "w")

f.write(module_file_data)

f.close()


#
#
#  THIS IS THE MPIF08 MODULE
#
#

def genFTypesforArg(args):
    ret = ""
    # Gen Calling Args
    for arg in args:

        ftype = ""
        fname = arg[1]
        fintent = ""
        farray = ""

        if (arg[0].find("[]") != -1):
            if len(arg) != 4:
                module_file_data += "!ARRERR"
            else:
                farray = "(" + arg[3] + ")"
                if arg[0] == "int[]":
                    ftype = "integer"
                elif arg[0] == "bool[]":
                    ftype = "logical"
                elif arg[0] == "int[][3]" or arg[0] == "bool[]":
                    ftype = "integer"
                    farray = "(3, " + arg[3] + " )"
                elif arg[0] == "MPI_Aint[]":
                    ftype = "integer*8"
                elif (arg[0].find("MPI_") != -1):
                    ftype = "type(" + arg[0].replace("[]", "") + "), target"
                else:
                    ftype = "!FAIL4 " + arg[0]
        else:
            # Handle conversion to Fortran Types
            if arg[0] == "MPI_Status*":
                ftype = "type(MPI_Status)"
            elif arg[0] == "MPI_Aint":
                ftype = "integer*8"
            elif arg[0] == "MPI_Offset":
                ftype = "integer*8"
            elif arg[0] == "MPI_Aint*":
                ftype = "integer*8"
            elif arg[0] == "MPI_Offset*":
                ftype = "integer*8"
            elif arg[0].find("MPI_") != -1:
                ftype = "type(" + arg[0].replace("*", "") + ")"
            elif arg[0] == "int":
                if arg[1] == "ierror":
                    ftype = "integer, optional, intent(out)"
                else:
                    ftype = "integer"
            elif arg[0] == "int*":
                ftype = "integer"
            elif arg[0] == "int[]":
                ftype = "integer"
            elif arg[0] == "char*":
                ftype = "character(len=*)"
            elif arg[0] == "bool":
                ftype = "logical"
            elif arg[0] == "void*":
                ftype = "type(*), dimension(..)"
            else:
                ftype = "FAIL8"

        fintent = getIntentforArg(arg)

        ret += ftype + fintent + " :: " + fname + farray + "\n"
    # DONE WALKING ARGS
    return ret


print("\n###############################")
print("Generating the F08 Fortran Module")
print("#################################\n")

module_file_data = genheader()


"""
 Write Module START
"""


module_file_data += "module mpi_f08\n"
module_file_data += "\n"
module_file_data += "\n"
module_file_data += "use,intrinsic :: iso_c_binding\n"
module_file_data += "\n"
module_file_data += "use :: mpi_f08_ctypes\n"
module_file_data += "use :: mpi_f08_types\n"
module_file_data += "use :: mpi_f08_constants\n"
module_file_data += "use :: mpi_f08_c\n"
module_file_data += "\n"
module_file_data += "implicit none\n"
module_file_data += "\n"


def containsConvert(args, char=1, array=1):
    for arg in args:
        if char and arg[0] == "char*":
            return 1
        if array and (3 < len(arg)):
            if arg[3] == "*":
                return 1

    return 0


for mpi_func, args in mpi_interface.items():

    if MPIFunctionsisPresentinMPC(mpi_func) == 0:
        continue

    if containsConvert(args):
        continue

    if (mpi_func.find("_c2f") != -1):
        continue

    f_func = mpi_func + "_f08"

    module_file_data += "\n"
    module_file_data += "interface " + mpi_func + "\n"
    # Gen decl
    module_file_data += "module procedure " + f_func + "\n"
    module_file_data += "end interface\n"
    module_file_data += "\n"

module_file_data += "\n"


for mpi_func, args in mpi_interface.items():

    if MPIFunctionsisPresentinMPC(mpi_func) == 0:
        continue

    if containsConvert(args):
        continue

    if (mpi_func.find("_c2f") != -1):
        continue

    f_func = mpi_func + "_f08"

    # Gen decl
    module_file_data += "private :: " + f_func + "\n"


module_file_data += "contains"


def getFtypeByName(typename):
    for t in f08types:
        # Skip the last empty elem
        if t.get("name") == None:
            continue
        if t["name"] == typename:
            return t
    return None


def convertToC(arg):
    global cnt
    intype = arg[0].replace("*", "")
    inname = arg[1]

    if intype in ["void"]:
        return ""

    dtype_array = ["int", "bool", "MPI_Status",
                   "MPI_Aint", "MPI_Offset", "MPI_Count"]
    if intype in dtype_array:
        return inname + "_c = " + inname + "\n"

    ftype = getFtypeByName(intype)

    layout = None

    if ftype != None:
        layout = ftype["layout"]

    if intype.find("[]") != -1:
        tinner = intype.replace("[]", "")
        if 3 < len(arg):
            convertToC.cnt += 1
            scnt = str(convertToC.cnt)
            ret = ""
            if arg[3] == "*":
                ret += "call mpi_comm_rank( comm, r_, n_ )\n"
                ret += "do " + scnt + " n_ = 1 , r_\n"
            else:
                ret += "do " + scnt + " n_ = 1 , " + arg[3] + "\n"
            if intype in ["int[]", "MPI_Request[]", "MPI_Status[]", "MPI_Aint[]", "MPI_Datatype[]"]:
                ret += inname + "_c(n_) = " + inname + "(n_)\n"
            else:
                if layout != None:
                    if len(layout) == 1:
                        ret += inname + "_c(n_) = " + inname + \
                            "(n_)%" + layout[0]["name"] + "\n"
                else:
                    ret += "!ERR LAYOUT " + intype + " \n"
            ret += scnt + " continue\n"
            return ret
        else:
            return "!NO LEN" + intype + " " + inname + "\n"

    if layout == None:
        return "!FAIL no conversion from " + intype + " for " + inname + "\n"

    if len(layout) == 1:
        return inname + "_c = " + inname + "%" + layout[0]["name"] + "\n"

    return ""


convertToC.cnt = 0


def convertToF(arg):
    intype = arg[0].replace("*", "")
    inname = arg[1]

    if intype == "void":
        return ""

    if intype in ["int", "bool", "MPI_Status", "MPI_Aint", "MPI_Offset", "MPI_Count"]:
        return inname + " = " + inname + "_c\n"

    ftype = getFtypeByName(intype)

    layout = None
    if ftype != None:
        layout = ftype["layout"]

    if intype.find("[]") != -1:
        tinner = intype.replace("[]", "")
        if 3 < len(arg):
            convertToC.cnt += 1
            scnt = str(convertToC.cnt)
            ret = ""
            if intype == "MPI_Status[]":
                ret += "if ( c_associated(c_loc("+inname + \
                    "), c_loc(MPI_STATUSES_IGNORE))&\n"
                ret += ".OR. ( c_associated(c_loc("+inname + \
                    "), c_loc(MPI_STATUS_IGNORE)))) then\n"
                ret += "    n_=2 !dummy operation\n"
                ret += "else\n"
            if arg[3] == "*":
                ret += "call mpi_comm_rank( comm, r_, n_ )\n"
                ret += "do " + scnt + " n_ = 1 , r_\n"
            else:
                ret += "do " + scnt + " n_ = 1 , " + arg[3] + "\n"
            if intype in ["int[]", "MPI_Request[]", "MPI_Status[]", "MPI_Aint[]", "MPI_Datatype[]"]:
                ret += inname + "(n_) = " + inname + "_c(n_)\n"
            else:
                if layout != None:
                    if len(layout) == 1:
                        ret += inname + "(n_) = " + inname + \
                            "_c(n_)%" + layout[0]["name"] + "\n"
                else:
                    ret += "!ERR LAYOUT " + intype + " \n"
            ret += scnt + " continue\n"
            if intype == "MPI_Status[]":
                ret += "end if\n"
            return ret
        else:
            return "!NO LEN" + intype + " " + inname + "\n"

    if ftype == None:
        return "!FAIL no conversion to " + intype + " for " + inname + "\n"

    if len(layout) == 1:
        return inname + "%" + layout[0]["name"] + " = " + inname + "_c\n"
    elif intype == "MPI_Status":
        return inname + " = " + inname + "_c\n"

    return ""


def f08wrapperGen(mpi_func, args):
    ret = ""
    if MPIFunctionsisPresentinMPC(mpi_func) == 0:
        ret += "\n"
        ret += "! " + mpi_func + " NOT IMPLEMENTED in MPC\n"
        ret += "\n"
        return ret

    if containsConvert(args) == 1:
        return "\n!Skipped convert function in " + mpi_func + "\n"

    ret += "\n"
    ret += "\n"

    f_func = mpi_func + "_f08"

    # Gen Wrapper function
    ret += "subroutine " + f_func
    ret += genCallArgs(args, 1) + "\n"
    ret += "\n"
    ret += "use :: mpi_f08_ctypes\n"
    ret += "use :: mpi_f08_types\n"
    ret += "use :: mpi_f08_c\n"
    ret += "\n"
    ret += "implicit none\n"
    ret += "\n"

    # Arguments
    ret += genFTypesforArg(args)

    ret += "\n"
    ret += "\n"

    # C transtyping decl
    ret += genCTypesforArg(args, "_c", 1)
    ret += "integer(c_int) :: ret ! dummy\n"
    ret += "integer(c_int) ::  n_ ! for array expansion\n"
    ret += "integer(c_int) ::  r_ ! for comm array expansion\n"

    # Transtyping

    ret += "\n"

    args_to_pass = []

    for arg in args:
        f_arg = arg[1]
        c_arg = f_arg + "_c"
        #ret += "\n!" + arg[0] + "\n"
        # Buffers are passed directly
        if arg[0] == "void*":
            args_to_pass.append(f_arg)
        else:
            if arg[0] == "MPI_Request[]":
                args_to_pass.append(f_arg + "%val")
            elif arg[0].find("[]") != -1:
                args_to_pass.append("c_loc(" + c_arg + ")")
            else:
                args_to_pass.append(c_arg)

        if arg[1] == "ierror":
            continue

        if 2 < len(arg):
            # Complete meta-data
            intent = arg[2]
        else:
            intent = "none"

        if intent in ["none", "in", "inout"]:
            ret += convertToC(arg)

    ret += "\n"
    ret += "ret = " + mpi_func + "_c("

    l = len(args_to_pass)
    for i in range(0, l):
        ret += args_to_pass[i]
        if i < (l-1):
            ret += ",&\n"

    ret += ")\n"
    ret += "\n"

    # Outyping
    for arg in args:
        if arg[1] == "ierror":
            continue

        if 2 < len(arg):
            # Complete meta-data
            intent = arg[2]
        else:
            intent = "none"

        if intent in ["none", "inout", "out"]:
            ret += convertToF(arg)

    ret += "\n"
    ret += "if( present(ierror)) ierror = ierror_c\n"
    ret += "\n"
    ret += "end subroutine " + f_func + "\n"
    return ret


for mpi_func, args in mpi_interface.items():
    if (mpi_func.find("_c2f") != -1):
        continue
    module_file_data += f08wrapperGen(mpi_func, args)


module_file_data += "\n"
module_file_data += "end module mpi_f08\n"


"""
 Open Output Module FILE
"""

f = open("mpi_f08.f90", "w")

f.write(module_file_data)

f.close()


print("\n###################################")
print("Generating the c MPIF08 Interface")
print("#####################################\n")


def containsVoid(args):
    for arg in args:
        if arg[0] == "void*":
            return 1

    return 0


def gencfunc(mpi_func, args, prefix="", suffix="", lower=0, rewrite_void=0, handle_char=0, all_pointers=0):
    rtype = "void"
    ret = ""
    if lower == 1:
        mpi_func = mpi_func.lower()
    ret += rtype + " " + prefix + mpi_func + suffix + "(\n"

    suffixed_char_size = ""

    for i in range(len(args)):
        arg = args[i]
        atype = arg[0]
        aname = arg[1]
        if len(arg) >= 3:
            intent = arg[2]
        else:
            intent = "notset"
        if atype.find("bool") != -1:
            atype = atype.replace("bool", "int*")
        if rewrite_void == 1:
            if atype == "void*":
                atype = "CFI_cdesc_t*"
                aname = aname + "_ptr"
        atype = atype.replace("[]", "*")
        atype = atype.replace("[3]", "*")
        if aname == "ierror":
            atype = "int *"
            aname = "ierror"
        if handle_char == 1:
            if atype == "char*":
                ret += " CHAR_MIXED(size_{0})".format(aname)
                suffixed_char_size += " CHAR_END(size_{0}),".format(aname)
        if all_pointers:
            if intent == "in":
                atype = atype+" *"
        ret += atype + " " + aname

        if i != (len(args) - 1):
            ret += ",\n"

    if suffixed_char_size:
        ret += "," + suffixed_char_size[:-1] + ")"
    else:
        ret += ")"
    return ret


def fortran_c_wrapper_gen(mpi_func, args, prefix="", suffix="", lower_names=1, rewrite_void=0, handle_char=0, all_pointers=0):
    ret = ""
    if MPIFunctionsisPresentinMPC(mpi_func) == 0:
        ret += "\n"
        ret += "/* " + mpi_func + " NOT IMPLEMENTED in MPC */\n"
        ret += "\n"
        return ret, True

    # We only want to convert cho
    skip_if_char = (not handle_char)
    if (containsConvert(args, char=skip_if_char) == 1):
        return "/* Skipped function " + mpi_func + "with conversion */\n", True

    ret += "\n"
    ret += "\n"

    # Gen delc (w underscore in lower)
    #ret += gencfunc( mpi_func, args, "_", 0)
    #ret += ";\n\n"

    # Gen Wrapper function
    ret += gencfunc(mpi_func, args, prefix, suffix, lower_names,
                    rewrite_void, handle_char, all_pointers=all_pointers)
    ret += "\n{\n"

    # EMIT CONVERSIONS
    for i in range(len(args)):
        arg = args[i]
        atype = arg[0]
        aname = arg[1]
        if len(arg) >= 3:
            intent = arg[2]
        else:
            intent = "notset"
        if rewrite_void and atype == "void*":
            ret += "void* " + aname + " = " + aname + "_ptr->base_addr;\n"
        if handle_char and atype == "char*" and intent.startswith("in"):
            ret += "char *tmp_{0}, *ptr_{0};\n".format(aname)
            ret += "tmp_{0} = sctk_char_fortran_to_c({0}, size_{0}, &ptr_{0});\n".format(
                aname)

    ret += "*ierror = " + mpi_func + \
        genCallArgs(args, 0, 0, pointer_args=all_pointers) + ";\n"

    # EMIT CONVERSIONS
    for i in range(len(args)):
        arg = args[i]
        atype = arg[0]
        aname = arg[1]
        if len(arg) >= 3:
            intent = arg[2]
        else:
            intent = "notset"
        if handle_char and atype == "char*" and intent.startswith("in"):
            ret += "sctk_free(ptr_{0});\n".format(aname)
        if handle_char and atype == "char*" and intent.endswith("out"):
            ret += "sctk_char_c_to_fortran({0}, size_{0});\n".format(aname)
        # if atype == "MPI_Status*":
            #ret += "fprintf(stderr, \"S : %d T : %d C : %ld \\n\" , status->MPC_SOURCE, status->MPC_TAG, status->size );\n"

    ret += "}"
    return ret, False


module_file_data = """
#include <mpi.h>
#include <stdint.h>
#include <stddef.h>

typedef struct {
         intptr_t  lower_bound,
                   extent,
                   sm;
} CFI_dim_t;

/* Maximum rank supported by the companion Fortran processor */

/* Changed from 15 to F2003 value of 7 (CER) */
#define CFI_MAX_RANK  7

/* Struct CFI_cdesc_t for holding all the information about a
   descriptor-based Fortran object */

typedef struct {
  void *        base_addr;          /* base address of object                      */
  size_t        elem_len;           /* length of one element, in bytes             */
  int           rank;               /* object rank, 0 .. CF_MAX_RANK               */
  int           type;               /* identifier for type of object               */
  int           attribute;          /* object attribute: 0..2, or -1               */
  int           state;              /* allocation/association state: 0 or 1        */
//Removed (CER)
//void *        fdesc;              /* pointer to corresponding Fortran descriptor */
  CFI_dim_t     dim[CFI_MAX_RANK];  /* dimension triples                           */
} CFI_cdesc_t;
"""

for mpi_func, args in mpi_interface.items():
    if (mpi_func.find("_c2f") != -1):
        continue
    (data, did_skip) = fortran_c_wrapper_gen(
        mpi_func, args, suffix="_f08", rewrite_void=1)
    module_file_data += data


"""
 Open Output C FILE
"""

f = open("mpi_f08_c_iface.c", "w")

f.write(module_file_data)

f.close()
