<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>parallel_do.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>parallel_do.h</h1><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment">    Copyright 2005-2008 Intel Corporation.  All Rights Reserved.</span>
00003 <span class="comment"></span>
00004 <span class="comment">    The source code contained or described herein and all documents related</span>
00005 <span class="comment">    to the source code ("Material") are owned by Intel Corporation or its</span>
00006 <span class="comment">    suppliers or licensors.  Title to the Material remains with Intel</span>
00007 <span class="comment">    Corporation or its suppliers and licensors.  The Material is protected</span>
00008 <span class="comment">    by worldwide copyright laws and treaty provisions.  No part of the</span>
00009 <span class="comment">    Material may be used, copied, reproduced, modified, published, uploaded,</span>
00010 <span class="comment">    posted, transmitted, distributed, or disclosed in any way without</span>
00011 <span class="comment">    Intel's prior express written permission.</span>
00012 <span class="comment"></span>
00013 <span class="comment">    No license under any patent, copyright, trade secret or other</span>
00014 <span class="comment">    intellectual property right is granted to or conferred upon you by</span>
00015 <span class="comment">    disclosure or delivery of the Materials, either expressly, by</span>
00016 <span class="comment">    implication, inducement, estoppel or otherwise.  Any license under such</span>
00017 <span class="comment">    intellectual property rights must be express and approved by Intel in</span>
00018 <span class="comment">    writing.</span>
00019 <span class="comment">*/</span>
00020 
00021 <span class="preprocessor">#ifndef __TBB_parallel_do_H</span>
00022 <span class="preprocessor"></span><span class="preprocessor">#define __TBB_parallel_do_H</span>
00023 <span class="preprocessor"></span>
00024 <span class="preprocessor">#include "task.h"</span>
00025 <span class="preprocessor">#include "aligned_space.h"</span>
00026 <span class="preprocessor">#include &lt;iterator&gt;</span>
00027 
00028 <span class="keyword">namespace </span>tbb {
00029 
00031 <span class="keyword">namespace </span>internal {
00032     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Body, <span class="keyword">typename</span> Item&gt; <span class="keyword">class </span>parallel_do_feeder_impl;
00033     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Body&gt; <span class="keyword">class </span>do_group_task;
00034 
00036     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
<a name="l00037"></a><a class="code" href="a00226.html">00037</a>     <span class="keyword">struct </span><a class="code" href="a00226.html">strip</a> { <span class="keyword">typedef</span> T type; };
00038     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
00039     <span class="keyword">struct </span><a class="code" href="a00226.html">strip</a>&lt;T&amp;&gt; { <span class="keyword">typedef</span> T type; };
00040     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
00041     <span class="keyword">struct </span>strip&lt;const T&amp;&gt; { <span class="keyword">typedef</span> T type; };
00042     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
00043     <span class="keyword">struct </span>strip&lt;volatile T&amp;&gt; { <span class="keyword">typedef</span> T type; };
00044     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
00045     <span class="keyword">struct </span>strip&lt;const volatile T&amp;&gt; { <span class="keyword">typedef</span> T type; };
00046     <span class="comment">// Most of the compilers remove cv-qualifiers from non-reference function argument types. </span>
00047     <span class="comment">// But unfortunately there are those that don't.</span>
00048     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
00049     <span class="keyword">struct </span>strip&lt;const T&gt; { <span class="keyword">typedef</span> T type; };
00050     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
00051     <span class="keyword">struct </span>strip&lt;volatile T&gt; { <span class="keyword">typedef</span> T type; };
00052     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
00053     <span class="keyword">struct </span>strip&lt;const volatile T&gt; { <span class="keyword">typedef</span> T type; };
00054 } <span class="comment">// namespace internal</span>
00056 <span class="comment"></span>
00058 
00059 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Item&gt;
<a name="l00060"></a><a class="code" href="a00201.html">00060</a> <span class="keyword">class </span><a class="code" href="a00201.html">parallel_do_feeder</a>: internal::no_copy
00061 {
00062     <a class="code" href="a00201.html">parallel_do_feeder</a>() {}
00063     <span class="keyword">virtual</span> ~<a class="code" href="a00201.html">parallel_do_feeder</a> () {}
00064     <span class="keyword">virtual</span> <span class="keywordtype">void</span> internal_add( <span class="keyword">const</span> Item&amp; item ) = 0;
00065     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Body_, <span class="keyword">typename</span> Item_&gt; <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="a00202.html">internal::parallel_do_feeder_impl</a>;
00066 <span class="keyword">public</span>:
<a name="l00068"></a><a class="code" href="a00201.html#a0">00068</a>     <span class="keywordtype">void</span> add( <span class="keyword">const</span> Item&amp; item ) {internal_add(item);}
00069 };
00070 
00072 <span class="keyword">namespace </span>internal {
00074 
00076     <span class="keyword">template</span>&lt;<span class="keyword">class</span> Body, <span class="keyword">typename</span> Item&gt;
<a name="l00077"></a><a class="code" href="a00203.html">00077</a>     <span class="keyword">class </span><a class="code" href="a00203.html">parallel_do_operator_selector</a>
00078     {
00079         <span class="keyword">typedef</span> <a class="code" href="a00201.html">parallel_do_feeder&lt;Item&gt;</a> <a class="code" href="a00201.html">Feeder</a>;
00080         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> A1, <span class="keyword">typename</span> A2, <span class="keyword">typename</span> CvItem &gt;
00081         <span class="keyword">static</span> <span class="keywordtype">void</span> internal_call( <span class="keyword">const</span> Body&amp; obj, A1&amp; arg1, A2&amp;, <span class="keywordtype">void</span> (Body::*)(CvItem) <span class="keyword">const</span> ) {
00082             obj(arg1);
00083         }
00084         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> A1, <span class="keyword">typename</span> A2, <span class="keyword">typename</span> CvItem &gt;
00085         <span class="keyword">static</span> <span class="keywordtype">void</span> internal_call( <span class="keyword">const</span> Body&amp; obj, A1&amp; arg1, A2&amp; arg2, <span class="keywordtype">void</span> (Body::*)(CvItem, <a class="code" href="a00201.html">parallel_do_feeder&lt;Item&gt;</a>&amp;) <span class="keyword">const</span> ) {
00086             obj(arg1, arg2);
00087         }
00088 
00089     <span class="keyword">public</span>:
00090         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> A1, <span class="keyword">typename</span> A2 &gt;
00091         <span class="keyword">static</span> <span class="keywordtype">void</span> call( <span class="keyword">const</span> Body&amp; obj, A1&amp; arg1, A2&amp; arg2 )
00092         {
00093             internal_call( obj, arg1, arg2, &amp;Body::operator() );
00094         }
00095     };
00096 
00098 
00100     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Body, <span class="keyword">typename</span> Item&gt;
<a name="l00101"></a><a class="code" href="a00186.html">00101</a>     <span class="keyword">class </span><a class="code" href="a00186.html">do_iteration_task</a>: <span class="keyword">public</span> <a class="code" href="a00228.html">task</a>
00102     {
00103         <span class="keyword">typedef</span> <a class="code" href="a00202.html">parallel_do_feeder_impl&lt;Body, Item&gt;</a> <a class="code" href="a00202.html">feeder_type</a>;
00104 
00105         Item my_value;
00106         <a class="code" href="a00202.html">feeder_type</a>&amp; my_feeder;
00107 
00108         <a class="code" href="a00186.html">do_iteration_task</a>( <span class="keyword">const</span> Item&amp; value, <a class="code" href="a00202.html">feeder_type</a>&amp; feeder ) : 
00109             my_value(value), my_feeder(feeder)
00110         {}
00111 
00112         <span class="comment">/*override*/</span> 
00113         <a class="code" href="a00228.html">task</a>* execute()
00114         {
00115             <a class="code" href="a00203.html">parallel_do_operator_selector&lt;Body, Item&gt;::call</a>(*my_feeder.my_body, my_value, my_feeder);
00116             <span class="keywordflow">return</span> NULL;
00117         }
00118 
00119         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Body_, <span class="keyword">typename</span> Item_&gt; <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="a00202.html">parallel_do_feeder_impl</a>;
00120     }; <span class="comment">// class do_iteration_task</span>
00121 
00122     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator, <span class="keyword">typename</span> Body, <span class="keyword">typename</span> Item&gt;
00123     <span class="keyword">class </span>do_iteration_task_iter: <span class="keyword">public</span> <a class="code" href="a00228.html">task</a>
00124     {
00125         <span class="keyword">typedef</span> <a class="code" href="a00202.html">parallel_do_feeder_impl&lt;Body, Item&gt;</a> feeder_type;
00126 
00127         Iterator my_iter;
00128         feeder_type&amp; my_feeder;
00129 
00130         do_iteration_task_iter( <span class="keyword">const</span> Iterator&amp; iter, feeder_type&amp; feeder ) : 
00131             my_iter(iter), my_feeder(feeder)
00132         {}
00133 
00134         <span class="comment">/*override*/</span> 
00135         <a class="code" href="a00228.html">task</a>* <a class="code" href="a00228.html#a1">execute</a>()
00136         {
00137             parallel_do_operator_selector&lt;Body, Item&gt;::call(*my_feeder.my_body, *my_iter, my_feeder);
00138             <span class="keywordflow">return</span> NULL;
00139         }
00140 
00141         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator_, <span class="keyword">typename</span> Body_, <span class="keyword">typename</span> Item_&gt; <span class="keyword">friend</span> <span class="keyword">class </span>do_group_task_forward;    
00142         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Body_, <span class="keyword">typename</span> Item_&gt; <span class="keyword">friend</span> <span class="keyword">class </span>do_group_task_input;    
00143         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator_, <span class="keyword">typename</span> Body_, <span class="keyword">typename</span> Item_&gt; <span class="keyword">friend</span> <span class="keyword">class </span>do_task_iter;    
00144     }; <span class="comment">// class do_iteration_task_iter</span>
00145 
00147 
00149     <span class="keyword">template</span>&lt;<span class="keyword">class</span> Body, <span class="keyword">typename</span> Item&gt;
<a name="l00150"></a><a class="code" href="a00202.html">00150</a>     <span class="keyword">class </span><a class="code" href="a00202.html">parallel_do_feeder_impl</a> : <span class="keyword">public</span> <a class="code" href="a00201.html">parallel_do_feeder</a>&lt;Item&gt;
00151     {
00152         <span class="comment">/*override*/</span> 
00153         <span class="keywordtype">void</span> internal_add( <span class="keyword">const</span> Item&amp; item )
00154         {
00155             <span class="keyword">typedef</span> <a class="code" href="a00186.html">do_iteration_task&lt;Body, Item&gt;</a> iteration_type;
00156 
00157             iteration_type&amp; t = *<span class="keyword">new</span> (task::self().allocate_additional_child_of(*my_barrier)) iteration_type(item, *<span class="keyword">this</span>);
00158 
00159             t.<a class="code" href="a00228.html#a14">spawn</a>( t );
00160         }
00161     <span class="keyword">public</span>:
00162         <span class="keyword">const</span> Body* my_body;
00163         <a class="code" href="a00188.html">empty_task</a>* my_barrier;
00164     }; <span class="comment">// class parallel_do_feeder_impl</span>
00165 
00166 
00168 
00171     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator, <span class="keyword">typename</span> Body, <span class="keyword">typename</span> Item&gt;
<a name="l00172"></a><a class="code" href="a00185.html">00172</a>     <span class="keyword">class </span><a class="code" href="a00185.html">do_group_task_forward</a>: <span class="keyword">public</span> <a class="code" href="a00228.html">task</a>
00173     {
00174         <span class="keyword">static</span> <span class="keyword">const</span> size_t max_arg_size = 4;         
00175 
00176         <span class="keyword">typedef</span> <a class="code" href="a00202.html">parallel_do_feeder_impl&lt;Body, Item&gt;</a> <a class="code" href="a00202.html">feeder_type</a>;
00177 
00178         <a class="code" href="a00202.html">feeder_type</a>&amp; my_feeder;
00179         Iterator my_first;
00180         size_t my_size;
00181         
00182         <a class="code" href="a00185.html">do_group_task_forward</a>( Iterator first, size_t size, <a class="code" href="a00202.html">feeder_type</a>&amp; feeder ) 
00183             : my_feeder(feeder), my_first(first), my_size(size)
00184         {}
00185 
00186         <span class="comment">/*override*/</span> <a class="code" href="a00228.html">task</a>* execute()
00187         {
00188             <span class="keyword">typedef</span> do_iteration_task_iter&lt;Iterator, Body, Item&gt; iteration_type;
00189             __TBB_ASSERT( my_size&gt;0, NULL );
00190             <a class="code" href="a00229.html">task_list</a> list;
00191             <a class="code" href="a00228.html">task</a>* t; 
00192             size_t k=0; 
00193             <span class="keywordflow">for</span>(;;) {
00194                 t = <span class="keyword">new</span>( allocate_child() ) iteration_type( my_first, my_feeder );
00195                 ++my_first;
00196                 <span class="keywordflow">if</span>( ++k==my_size ) <span class="keywordflow">break</span>;
00197                 list.<a class="code" href="a00229.html#a3">push_back</a>(*t);
00198             }
00199             set_ref_count(<span class="keywordtype">int</span>(k+1));
00200             spawn(list);
00201             spawn_and_wait_for_all(*t);
00202             <span class="keywordflow">return</span> NULL;
00203         }
00204 
00205         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator_, <span class="keyword">typename</span> Body_, <span class="keyword">typename</span> _Item&gt; <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="a00187.html">do_task_iter</a>;
00206     }; <span class="comment">// class do_group_task_forward</span>
00207 
00208     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Body, <span class="keyword">typename</span> Item&gt;
00209     <span class="keyword">class </span>do_group_task_input: <span class="keyword">public</span> <a class="code" href="a00228.html">task</a>
00210     {
00211         <span class="keyword">static</span> <span class="keyword">const</span> size_t max_arg_size = 4;         
00212         
00213         <span class="keyword">typedef</span> <a class="code" href="a00202.html">parallel_do_feeder_impl&lt;Body, Item&gt;</a> feeder_type;
00214 
00215         feeder_type&amp; my_feeder;
00216         size_t my_size;
00217         <a class="code" href="a00164.html">aligned_space&lt;Item, max_arg_size&gt;</a> my_arg;
00218 
00219         do_group_task_input( feeder_type&amp; feeder ) 
00220             : my_feeder(feeder), my_size(0)
00221         {}
00222 
00223         <span class="comment">/*override*/</span> <a class="code" href="a00228.html">task</a>* <a class="code" href="a00228.html#a1">execute</a>()
00224         {
00225             <span class="keyword">typedef</span> do_iteration_task_iter&lt;Item*, Body, Item&gt; iteration_type;
00226             __TBB_ASSERT( my_size&gt;0, NULL );
00227             <a class="code" href="a00229.html">task_list</a> list;
00228             <a class="code" href="a00228.html">task</a>* t; 
00229             size_t k=0; 
00230             <span class="keywordflow">for</span>(;;) {
00231                 t = <span class="keyword">new</span>( <a class="code" href="a00228.html#a3">allocate_child</a>() ) iteration_type( my_arg.begin() + k, my_feeder );
00232                 <span class="keywordflow">if</span>( ++k==my_size ) <span class="keywordflow">break</span>;
00233                 list.<a class="code" href="a00229.html#a3">push_back</a>(*t);
00234             }
00235             <a class="code" href="a00228.html#a13">set_ref_count</a>(<span class="keywordtype">int</span>(k+1));
00236             <a class="code" href="a00228.html#a14">spawn</a>(list);
00237             <a class="code" href="a00228.html#a16">spawn_and_wait_for_all</a>(*t);
00238             <span class="keywordflow">return</span> NULL;
00239         }
00240 
00241         ~do_group_task_input(){
00242             <span class="keywordflow">for</span>( size_t k=0; k&lt;my_size; ++k)
00243                 (my_arg.begin() + k)-&gt;~Item();
00244         }
00245 
00246         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator_, <span class="keyword">typename</span> Body_, <span class="keyword">typename</span> Item_&gt; <span class="keyword">friend</span> <span class="keyword">class </span>do_task_iter;
00247     }; <span class="comment">// class do_group_task_input</span>
00248     
00250 
00252     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator, <span class="keyword">typename</span> Body, <span class="keyword">typename</span> Item&gt;
<a name="l00253"></a><a class="code" href="a00187.html">00253</a>     <span class="keyword">class </span><a class="code" href="a00187.html">do_task_iter</a>: <span class="keyword">public</span> <a class="code" href="a00228.html">task</a>
00254     {
00255         <span class="comment">//typedef typename std::iterator_traits&lt;Iterator&gt;::value_type Item;</span>
00256         <span class="keyword">typedef</span> <a class="code" href="a00202.html">parallel_do_feeder_impl&lt;Body, Item&gt;</a> <a class="code" href="a00202.html">feeder_type</a>;
00257 
00258     <span class="keyword">public</span>:
00259         <a class="code" href="a00187.html">do_task_iter</a>( Iterator first, Iterator last , <a class="code" href="a00202.html">feeder_type</a>&amp; feeder ) : 
00260             my_first(first), my_last(last), my_feeder(feeder)
00261         {}
00262     
00263     <span class="keyword">private</span>:
00264         Iterator my_first;
00265         Iterator my_last;
00266         <a class="code" href="a00202.html">feeder_type</a>&amp; my_feeder;
00267 
00268         <span class="comment">/* Do not merge run(xxx) and run_xxx() methods. They are separated in order</span>
00269 <span class="comment">            to make sure that compilers will eliminate unused argument of type xxx</span>
00270 <span class="comment">            (that is will not put it on stack). The sole purpose of this argument </span>
00271 <span class="comment">            is overload resolution.</span>
00272 <span class="comment">            </span>
00273 <span class="comment">            An alternative could be using template functions, but explicit specialization </span>
00274 <span class="comment">            of member function templates is not supported for non specialized class </span>
00275 <span class="comment">            templates. Besides template functions would always fall back to the least </span>
00276 <span class="comment">            efficient variant (the one for input iterators) in case of iterators having </span>
00277 <span class="comment">            custom tags derived from basic ones. */</span>
00278         <span class="comment">/*override*/</span> <a class="code" href="a00228.html">task</a>* execute()
00279         {
00280             <span class="keyword">typedef</span> <span class="keyword">typename</span> std::iterator_traits&lt;Iterator&gt;::iterator_category iterator_tag;
00281             <span class="keywordflow">return</span> run( (iterator_tag*)NULL );
00282         }
00283 
00286         <span class="keyword">inline</span> <a class="code" href="a00228.html">task</a>* run( <span class="keywordtype">void</span>* ) { <span class="keywordflow">return</span> run_for_input_iterator(); }
00287         
00288         <a class="code" href="a00228.html">task</a>* run_for_input_iterator() {
00289             <span class="keyword">typedef</span> do_group_task_input&lt;Body, Item&gt; block_type;
00290 
00291             block_type&amp; t = *<span class="keyword">new</span>( allocate_additional_child_of(*my_feeder.my_barrier) ) block_type(my_feeder);
00292             size_t k=0; 
00293             <span class="keywordflow">while</span>( !(my_first == my_last) ) {
00294                 <span class="keyword">new</span> (t.my_arg.begin() + k) Item(*my_first);
00295                 ++my_first;
00296                 <span class="keywordflow">if</span>( ++k==block_type::max_arg_size ) {
00297                     <span class="keywordflow">if</span> ( !(my_first == my_last) )
00298                         recycle_to_reexecute();
00299                     <span class="keywordflow">break</span>;
00300                 }
00301             }
00302             <span class="keywordflow">if</span>( k==0 ) {
00303                 destroy(t);
00304                 <span class="keywordflow">return</span> NULL;
00305             } <span class="keywordflow">else</span> {
00306                 t.my_size = k;
00307                 <span class="keywordflow">return</span> &amp;t;
00308             }
00309         }
00310 
00311         <span class="keyword">inline</span> <a class="code" href="a00228.html">task</a>* run( std::forward_iterator_tag* ) { <span class="keywordflow">return</span> run_for_forward_iterator(); }
00312 
00313         <a class="code" href="a00228.html">task</a>* run_for_forward_iterator() {
00314             <span class="keyword">typedef</span> <a class="code" href="a00185.html">do_group_task_forward&lt;Iterator, Body, Item&gt;</a> block_type;
00315 
00316             Iterator first = my_first;
00317             size_t k=0; 
00318             <span class="keywordflow">while</span>( !(my_first==my_last) ) {
00319                 ++my_first;
00320                 <span class="keywordflow">if</span>( ++k==block_type::max_arg_size ) {
00321                     <span class="keywordflow">if</span> ( !(my_first==my_last) )
00322                         recycle_to_reexecute();
00323                     <span class="keywordflow">break</span>;
00324                 }
00325             }
00326             <span class="keywordflow">return</span> k==0 ? NULL : <span class="keyword">new</span>( allocate_additional_child_of(*my_feeder.my_barrier) ) block_type(first, k, my_feeder);
00327         }
00328         
00329         <span class="keyword">inline</span> <a class="code" href="a00228.html">task</a>* run( std::random_access_iterator_tag* ) { <span class="keywordflow">return</span> run_for_random_access_iterator(); }
00330 
00331         <a class="code" href="a00228.html">task</a>* run_for_random_access_iterator() {
00332             <span class="keyword">typedef</span> <a class="code" href="a00185.html">do_group_task_forward&lt;Iterator, Body, Item&gt;</a> block_type;
00333             <span class="keyword">typedef</span> do_iteration_task_iter&lt;Iterator, Body, Item&gt; iteration_type;
00334             
00335             size_t k = static_cast&lt;size_t&gt;(my_last-my_first); 
00336             <span class="keywordflow">if</span>( k &gt; block_type::max_arg_size ) {
00337                 Iterator middle = my_first + k/2;
00338 
00339                 <a class="code" href="a00188.html">empty_task</a>&amp; c = *<span class="keyword">new</span>( allocate_continuation() ) <a class="code" href="a00188.html">empty_task</a>;
00340                 <a class="code" href="a00187.html">do_task_iter</a>&amp; b = *<span class="keyword">new</span>( c.<a class="code" href="a00228.html#a3">allocate_child</a>() ) <a class="code" href="a00187.html">do_task_iter</a>(middle, my_last, my_feeder);
00341                 recycle_as_child_of(c);
00342 
00343                 my_last = middle;
00344                 c.<a class="code" href="a00228.html#a13">set_ref_count</a>(2);
00345                 c.<a class="code" href="a00228.html#a14">spawn</a>(b);
00346                 <span class="keywordflow">return</span> <span class="keyword">this</span>;
00347             }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( k != 0 ) {
00348                 <a class="code" href="a00229.html">task_list</a> list;
00349                 <a class="code" href="a00228.html">task</a>* t; 
00350                 size_t k1=0; 
00351                 <span class="keywordflow">for</span>(;;) {
00352                     t = <span class="keyword">new</span>( allocate_child() ) iteration_type(my_first, my_feeder);
00353                     ++my_first;
00354                     <span class="keywordflow">if</span>( ++k1==k ) <span class="keywordflow">break</span>;
00355                     list.<a class="code" href="a00229.html#a3">push_back</a>(*t);
00356                 }
00357                 set_ref_count(<span class="keywordtype">int</span>(k+1));
00358                 spawn(list);
00359                 spawn_and_wait_for_all(*t);
00360             }
00361             <span class="keywordflow">return</span> NULL;
00362         }
00363     }; <span class="comment">// class do_task_iter</span>
00364 
00366 
00368     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator, <span class="keyword">typename</span> Body, <span class="keyword">typename</span> Item&gt; 
<a name="l00369"></a><a class="code" href="a00281.html#ga0">00369</a>     <span class="keywordtype">void</span> <a class="code" href="a00281.html#ga0">run_parallel_do</a>( Iterator first, Iterator last, <span class="keyword">const</span> Body&amp; body )
00370     {
00371         <span class="keyword">typedef</span> do_task_iter&lt;Iterator, Body, Item&gt; root_iteration_task;
00372         parallel_do_feeder_impl&lt;Body, Item&gt; feeder;
00373         feeder.my_body = &amp;body;
00374         feeder.my_barrier = <span class="keyword">new</span>( task::allocate_root() ) empty_task();
00375         __TBB_ASSERT(feeder.my_barrier, <span class="stringliteral">"root task allocation failed"</span>);
00376 
00377         root_iteration_task &amp;t = *<span class="keyword">new</span>( feeder.my_barrier-&gt;allocate_child() ) root_iteration_task(first, last, feeder);
00378 
00379         feeder.my_barrier-&gt;set_ref_count(2);
00380         feeder.my_barrier-&gt;spawn_and_wait_for_all(t);
00381 
00382         feeder.my_barrier-&gt;destroy(*feeder.my_barrier);
00383     }
00384 
00386 
00388     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator, <span class="keyword">typename</span> Body, <span class="keyword">typename</span> Item&gt; 
<a name="l00389"></a><a class="code" href="a00281.html#ga1">00389</a>     <span class="keywordtype">void</span> <a class="code" href="a00281.html#ga2">select_parallel_do</a>( Iterator first, Iterator last, <span class="keyword">const</span> Body&amp; body, <span class="keywordtype">void</span> (Body::*)(Item) <span class="keyword">const</span> )
00390     {
00391         run_parallel_do&lt;Iterator, Body, typename strip&lt;Item&gt;::type&gt;( first, last, body );
00392     }
00393 
00395 
00397     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator, <span class="keyword">typename</span> Body, <span class="keyword">typename</span> Item, <span class="keyword">typename</span> _Item&gt; 
<a name="l00398"></a><a class="code" href="a00281.html#ga2">00398</a>     <span class="keywordtype">void</span> <a class="code" href="a00281.html#ga2">select_parallel_do</a>( Iterator first, Iterator last, <span class="keyword">const</span> Body&amp; body, <span class="keywordtype">void</span> (Body::*)(Item, parallel_do_feeder&lt;_Item&gt;&amp;) <span class="keyword">const</span> )
00399     {
00400         run_parallel_do&lt;Iterator, Body, typename strip&lt;Item&gt;::type&gt;( first, last, body );
00401     }
00402 
00403 } <span class="comment">// namespace internal</span>
00405 <span class="comment"></span>
00406 
00429 
00430 
00431 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator, <span class="keyword">typename</span> Body&gt; 
<a name="l00432"></a><a class="code" href="a00281.html#ga3">00432</a> <span class="keywordtype">void</span> <a class="code" href="a00281.html#ga3">parallel_do</a>( Iterator first, Iterator last, <span class="keyword">const</span> Body&amp; body )
00433 {
00434     <span class="keywordflow">if</span> ( first == last )
00435         <span class="keywordflow">return</span>;
00436     <a class="code" href="a00281.html#ga2">internal::select_parallel_do</a>( first, last, body, &amp;Body::operator() );
00437 }
00439 
00440 } <span class="comment">// namespace </span>
00441 
00442 <span class="preprocessor">#endif </span><span class="comment">/* __TBB_parallel_do_H */</span>
</pre></div><hr>
<p></p>
Copyright &copy; 2005-2008 Intel Corporation.  All Rights Reserved.
<p></p>
Intel, Pentium, Intel Xeon, Itanium, Intel XScale and VTune are
registered trademarks or trademarks of Intel Corporation or its
subsidiaries in the United States and other countries.
<p></p>
* Other names and brands may be claimed as the property of others.
