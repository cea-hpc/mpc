<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>tbb::internal Namespace Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>tbb::internal Namespace Reference</h1>INTERNAL  
<a href="#_details">More...</a>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::internal::atomic_traits&lt; Size, M &gt;</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::internal::atomic_word&lt; Size &gt;</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::internal::atomic_base&lt; I &gt;</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::internal::atomic_word&lt; 8 &gt;</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::internal::atomic_base&lt; uint64_t &gt;</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::internal::atomic_base&lt; int64_t &gt;</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::internal::atomic_impl&lt; I, D, Step &gt;</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html">tbb::internal::hash_map_base</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">base class of <a class="el" href="a00174.html">concurrent_hash_map</a>  <a href="a00195.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::internal::hash_map_segment_base</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00196.html">tbb::internal::hash_map_iterator&lt; Container, Value &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Meets requirements of a forward iterator for STL */.  <a href="a00196.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html">tbb::internal::hash_map_range&lt; Iterator &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Range class used with <a class="el" href="a00174.html">concurrent_hash_map</a>.  <a href="a00197.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00178.html">tbb::internal::concurrent_queue_base_v3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For internal use only.  <a href="a00178.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00179.html">tbb::internal::concurrent_queue_base_v3::page</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prefix on a page.  <a href="a00179.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00181.html">tbb::internal::concurrent_queue_iterator_base_v3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type-independent portion of <a class="el" href="a00180.html">concurrent_queue_iterator</a>.  <a href="a00181.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00180.html">tbb::internal::concurrent_queue_iterator&lt; Container, Value &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Meets requirements of a forward iterator for STL.  <a href="a00180.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00183.html">tbb::internal::concurrent_vector_base_v3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base class of concurrent vector implementation.  <a href="a00183.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::internal::concurrent_vector_base_v3::segment_t</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00184.html">tbb::internal::concurrent_vector_base_v3::internal_segments_table</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal structure for compact().  <a href="a00184.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00238.html">tbb::internal::vector_iterator&lt; Container, Value &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Meets requirements of a forward iterator for STL and a Value for a <a class="el" href="a00169.html">blocked_range</a>.*/.  <a href="a00238.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::internal::allocator_base&lt; T, A &gt;</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00226.html">tbb::internal::strip&lt; T &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Strips its template type argument from 'cv' and '&amp;' qualifiers.  <a href="a00226.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::internal::strip&lt; T &amp; &gt;</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::internal::strip&lt; const T &amp; &gt;</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::internal::strip&lt; volatile T &amp; &gt;</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::internal::strip&lt; const volatile T &amp; &gt;</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::internal::strip&lt; const T &gt;</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::internal::strip&lt; volatile T &gt;</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::internal::strip&lt; const volatile T &gt;</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00203.html">tbb::internal::parallel_do_operator_selector&lt; Body, Item &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For internal use only.  <a href="a00203.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00186.html">tbb::internal::do_iteration_task&lt; Body, Item &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For internal use only.  <a href="a00186.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::internal::do_iteration_task_iter&lt; Iterator, Body, Item &gt;</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00202.html">tbb::internal::parallel_do_feeder_impl&lt; Body, Item &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For internal use only.  <a href="a00202.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html">tbb::internal::do_group_task_forward&lt; Iterator, Body, Item &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For internal use only.  <a href="a00185.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::internal::do_group_task_input&lt; Body, Item &gt;</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00187.html">tbb::internal::do_task_iter&lt; Iterator, Body, Item &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For internal use only.  <a href="a00187.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00222.html">tbb::internal::start_for&lt; Range, Body, Partitioner &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Task type used in parallel_for.  <a href="a00222.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00192.html">tbb::internal::finish_reduce&lt; Body &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Task type use to combine the partial results of parallel_reduce.  <a href="a00192.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00223.html">tbb::internal::start_reduce&lt; Range, Body, Partitioner &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Task type used to split the work of parallel_reduce.  <a href="a00223.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00193.html">tbb::internal::finish_reduce_with_affinity&lt; Body &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Task type use to combine the partial results of parallel_reduce with <a class="el" href="a00162.html">affinity_partitioner</a>.  <a href="a00193.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html">tbb::internal::start_reduce_with_affinity&lt; Range, Body &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Task type used to split the work of parallel_reduce with <a class="el" href="a00162.html">affinity_partitioner</a>.  <a href="a00224.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html">tbb::internal::final_sum&lt; Range, Body &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs final scan for a leaf.  <a href="a00191.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00227.html">tbb::internal::sum_node&lt; Range, Body &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Split work to be done in the scan.  <a href="a00227.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00194.html">tbb::internal::finish_scan&lt; Range, Body &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Combine partial results.  <a href="a00194.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00225.html">tbb::internal::start_scan&lt; Range, Body, Partitioner &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initial task to split the work.  <a href="a00225.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00213.html">tbb::internal::quick_sort_range&lt; RandomAccessIterator, Compare &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Range used in quicksort to split elements into subranges based on a value.  <a href="a00213.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00212.html">tbb::internal::quick_sort_body&lt; RandomAccessIterator, Compare &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Body class used to sort elements in a range that is smaller than the grainsize.  <a href="a00212.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00241.html">tbb::internal::while_iteration_task&lt; Body &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For internal use only.  <a href="a00241.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00240.html">tbb::internal::while_group_task&lt; Body &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For internal use only.  <a href="a00240.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00242.html">tbb::internal::while_task&lt; Stream, Body &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For internal use only.  <a href="a00242.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00163.html">tbb::internal::affinity_partitioner_base_v3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Defines entry points into tbb run-time library;.  <a href="a00163.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00205.html">tbb::internal::partition_type_base</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provides default methods for partition objects without affinity.  <a href="a00205.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::internal::affinity_partition_type</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::internal::scheduler</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::internal::allocate_root_proxy</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::internal::allocate_continuation_proxy</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::internal::allocate_child_proxy</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::internal::allocate_additional_child_of_proxy</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00230.html">tbb::internal::task_prefix</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Memory prefix to a task object.  <a href="a00230.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::internal::task_scheduler_observer_v3</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00166.html">tbb::internal::AtomicBackoff</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class that implements exponential backoff.  <a href="a00166.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::internal::type_with_alignment&lt; N &gt;</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::internal::type_with_alignment&lt; 1 &gt;</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::internal::type_with_alignment&lt; 2 &gt;</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::internal::type_with_alignment&lt; 4 &gt;</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::internal::type_with_alignment&lt; 8 &gt;</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00200.html">tbb::internal::no_copy</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base class for types that should not be copied or assigned.  <a href="a00200.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00239.html">tbb::internal::version_tag_v3</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::internal::thread_closure_base</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::internal::thread_closure_0&lt; F &gt;</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00235.html">tbb::internal::thread_closure_1&lt; F, X &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure used to pass user function with 1 argument to thread.  <a href="a00235.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::internal::thread_closure_2&lt; F, X, Y &gt;</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00234.html">tbb::internal::tbb_thread_v3</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Versioned thread class.  <a href="a00234.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>tbb::internal::tbb_thread_v3::id</b></td></tr>

<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a1" doxytag="tbb::internal::concurrent_queue_base"></a>
typedef <a class="el" href="a00178.html">concurrent_queue_base_v3</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>concurrent_queue_base</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a2" doxytag="tbb::internal::concurrent_queue_iterator_base"></a>
typedef <a class="el" href="a00181.html">concurrent_queue_iterator_base_v3</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>concurrent_queue_iterator_base</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a3" doxytag="tbb::internal::concurrent_vector_base"></a>
typedef <a class="el" href="a00183.html">concurrent_vector_base_v3</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>concurrent_vector_base</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00279.html#a4">reduction_context</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">0 if root, 1 if a left child, 2 if a right child.  <a href="#a4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a9" doxytag="tbb::internal::Token"></a>
typedef unsigned long&nbsp;</td><td class="memItemRight" valign="bottom"><b>Token</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a10" doxytag="tbb::internal::tokendiff_t"></a>
typedef long&nbsp;</td><td class="memItemRight" valign="bottom"><b>tokendiff_t</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="a00279.html#a14">intptr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00279.html#a11">reference_count</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A reference count.  <a href="#a11"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a12" doxytag="tbb::internal::affinity_id"></a>
typedef unsigned short&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00279.html#a12">affinity_id</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An id as used for specifying affinity. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00279.html#a13">uintptr</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An unsigned integral type big enough to hold a pointer.  <a href="#a13"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef std::ptrdiff_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00279.html#a14">intptr</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A signed integral type big enough to hold a pointer.  <a href="#a14"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a15" doxytag="tbb::internal::version_tag"></a>
typedef <a class="el" href="a00239.html">version_tag_v3</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>version_tag</b></td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a16" doxytag="tbb::internal::NFS_GetLineSize"></a>
size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00279.html#a16">NFS_GetLineSize</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cache/sector line size. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a17" doxytag="tbb::internal::NFS_Allocate"></a>
void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00279.html#a17">NFS_Allocate</a> (size_t n_element, size_t element_size, void *hint)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate memory on cache/sector line boundary. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00279.html#a18">NFS_Free</a> (void *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free memory allocated by NFS_Allocate.  <a href="#a18"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a19" doxytag="tbb::internal::operator=="></a>
template&lt;typename Container, typename T, typename U&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="a00196.html">hash_map_iterator</a>&lt; Container, T &gt; &amp;i, const <a class="el" href="a00196.html">hash_map_iterator</a>&lt; Container, U &gt; &amp;j)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a20" doxytag="tbb::internal::operator!="></a>
template&lt;typename Container, typename T, typename U&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="a00196.html">hash_map_iterator</a>&lt; Container, T &gt; &amp;i, const <a class="el" href="a00196.html">hash_map_iterator</a>&lt; Container, U &gt; &amp;j)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a21" doxytag="tbb::internal::operator=="></a>
template&lt;typename C, typename T, typename U&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="a00180.html">concurrent_queue_iterator</a>&lt; C, T &gt; &amp;i, const <a class="el" href="a00180.html">concurrent_queue_iterator</a>&lt; C, U &gt; &amp;j)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a22" doxytag="tbb::internal::operator!="></a>
template&lt;typename C, typename T, typename U&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="a00180.html">concurrent_queue_iterator</a>&lt; C, T &gt; &amp;i, const <a class="el" href="a00180.html">concurrent_queue_iterator</a>&lt; C, U &gt; &amp;j)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a23" doxytag="tbb::internal::operator+"></a>
template&lt;typename Container, typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="a00238.html">vector_iterator</a>&lt; Container,<br>
 T &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (ptrdiff_t offset, const <a class="el" href="a00238.html">vector_iterator</a>&lt; Container, T &gt; &amp;v)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a24" doxytag="tbb::internal::operator=="></a>
template&lt;typename Container, typename T, typename U&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="a00238.html">vector_iterator</a>&lt; Container, T &gt; &amp;i, const <a class="el" href="a00238.html">vector_iterator</a>&lt; Container, U &gt; &amp;j)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a25" doxytag="tbb::internal::operator!="></a>
template&lt;typename Container, typename T, typename U&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="a00238.html">vector_iterator</a>&lt; Container, T &gt; &amp;i, const <a class="el" href="a00238.html">vector_iterator</a>&lt; Container, U &gt; &amp;j)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a26" doxytag="tbb::internal::operator<"></a>
template&lt;typename Container, typename T, typename U&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="a00238.html">vector_iterator</a>&lt; Container, T &gt; &amp;i, const <a class="el" href="a00238.html">vector_iterator</a>&lt; Container, U &gt; &amp;j)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a27" doxytag="tbb::internal::operator>"></a>
template&lt;typename Container, typename T, typename U&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="a00238.html">vector_iterator</a>&lt; Container, T &gt; &amp;i, const <a class="el" href="a00238.html">vector_iterator</a>&lt; Container, U &gt; &amp;j)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a28" doxytag="tbb::internal::operator>="></a>
template&lt;typename Container, typename T, typename U&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="a00238.html">vector_iterator</a>&lt; Container, T &gt; &amp;i, const <a class="el" href="a00238.html">vector_iterator</a>&lt; Container, U &gt; &amp;j)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a29" doxytag="tbb::internal::operator<="></a>
template&lt;typename Container, typename T, typename U&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="a00238.html">vector_iterator</a>&lt; Container, T &gt; &amp;i, const <a class="el" href="a00238.html">vector_iterator</a>&lt; Container, U &gt; &amp;j)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a30" doxytag="tbb::internal::operator-"></a>
template&lt;typename Container, typename T, typename U&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">ptrdiff_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator-</b> (const <a class="el" href="a00238.html">vector_iterator</a>&lt; Container, T &gt; &amp;i, const <a class="el" href="a00238.html">vector_iterator</a>&lt; Container, U &gt; &amp;j)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a31" doxytag="tbb::internal::handle_perror"></a>
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>handle_perror</b> (int error_code, const char *what)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Iterator, typename Body, typename Item&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00281.html#ga0">run_parallel_do</a> (Iterator first, Iterator last, const Body &amp;body)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For internal use only.  <a href="a00281.html#ga0"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Iterator, typename Body, typename Item&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00281.html#ga1">select_parallel_do</a> (Iterator first, Iterator last, const Body &amp;body, void(Body::*)(Item) const )</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For internal use only.  <a href="a00281.html#ga1"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Iterator, typename Body, typename Item, typename _Item&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00281.html#ga2">select_parallel_do</a> (Iterator first, Iterator last, const Body &amp;body, void(Body::*)(Item, <a class="el" href="a00201.html">parallel_do_feeder</a>&lt; _Item &gt; &amp;) const )</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For internal use only.  <a href="a00281.html#ga2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a35" doxytag="tbb::internal::itt_store_pointer_with_release_v3"></a>
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00279.html#a35">itt_store_pointer_with_release_v3</a> (void *dst, void *src)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ITT instrumented routine that stores src into location pointed to by dst. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a36" doxytag="tbb::internal::itt_load_pointer_with_acquire_v3"></a>
void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00279.html#a36">itt_load_pointer_with_acquire_v3</a> (const void *src)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ITT instrumented routine that loads pointer from location pointed to by src. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a37" doxytag="tbb::internal::parallel_reduce_store_body"></a>
template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_reduce_store_body</b> (T *&amp;dst, T *src)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a38" doxytag="tbb::internal::parallel_reduce_load_body"></a>
template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">T *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>parallel_reduce_load_body</b> (T *&amp;src)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="ga12" doxytag="tbb::internal::parallel_quick_sort"></a>
template&lt;typename RandomAccessIterator, typename Compare&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00281.html#ga12">parallel_quick_sort</a> (RandomAccessIterator begin, RandomAccessIterator end, const Compare &amp;comp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wrapper method to initiate the sort by calling parallel_for. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a40" doxytag="tbb::internal::get_initial_auto_partitioner_divisor"></a>
size_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>get_initial_auto_partitioner_divisor</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00279.html#a41">deallocate_via_handler_v3</a> (void *p)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deallocates memory using FreeHandler.  <a href="#a41"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00279.html#a42">allocate_via_handler_v3</a> (size_t n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocates memory using MallocHandler.  <a href="#a42"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a43" doxytag="tbb::internal::is_malloc_used_v3"></a>
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00279.html#a43">is_malloc_used_v3</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if standard malloc/free are used to work with memory. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a44" doxytag="tbb::internal::__TBB_MaskedCompareAndSwap"></a>
template&lt;size_t S, typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">intptr_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>__TBB_MaskedCompareAndSwap</b> (volatile int32_t *ptr, T value, T comparand)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a45" doxytag="tbb::internal::__TBB_CompareAndSwapGeneric"></a>
template&lt;size_t S, typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>__TBB_CompareAndSwapGeneric</b> (volatile void *ptr, T value, T comparand)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a46" doxytag="tbb::internal::__TBB_CompareAndSwapGeneric< 1, uint8_t >"></a>
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">uint8_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>__TBB_CompareAndSwapGeneric&lt; 1, uint8_t &gt;</b> (volatile void *ptr, uint8_t value, uint8_t comparand)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a47" doxytag="tbb::internal::__TBB_CompareAndSwapGeneric< 2, uint16_t >"></a>
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">uint16_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>__TBB_CompareAndSwapGeneric&lt; 2, uint16_t &gt;</b> (volatile void *ptr, uint16_t value, uint16_t comparand)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a48" doxytag="tbb::internal::__TBB_CompareAndSwapGeneric< 4, uint32_t >"></a>
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">uint32_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>__TBB_CompareAndSwapGeneric&lt; 4, uint32_t &gt;</b> (volatile void *ptr, uint32_t value, uint32_t comparand)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a49" doxytag="tbb::internal::__TBB_CompareAndSwapGeneric< 8, uint64_t >"></a>
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">uint64_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>__TBB_CompareAndSwapGeneric&lt; 8, uint64_t &gt;</b> (volatile void *ptr, uint64_t value, uint64_t comparand)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a50" doxytag="tbb::internal::__TBB_FetchAndAddGeneric"></a>
template&lt;size_t S, typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>__TBB_FetchAndAddGeneric</b> (volatile void *ptr, T addend)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a51" doxytag="tbb::internal::__TBB_FetchAndStoreGeneric"></a>
template&lt;size_t S, typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>__TBB_FetchAndStoreGeneric</b> (volatile void *ptr, T value)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a52" doxytag="tbb::internal::runtime_warning"></a>
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00279.html#a52">runtime_warning</a> (const char *format,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Report a runtime warning. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a53" doxytag="tbb::internal::poison_pointer"></a>
template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>poison_pointer</b> (T *)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a54" doxytag="tbb::internal::allocate_closure_v3"></a>
void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00279.html#a54">allocate_closure_v3</a> (size_t size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a closure. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a55" doxytag="tbb::internal::free_closure_v3"></a>
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00279.html#a55">free_closure_v3</a> (void *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free a closure allocated by allocate_closure_v3. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a56" doxytag="tbb::internal::move_v3"></a>
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>move_v3</b> (<a class="el" href="a00234.html">tbb_thread_v3</a> &amp;t1, <a class="el" href="a00234.html">tbb_thread_v3</a> &amp;t2)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a57" doxytag="tbb::internal::thread_get_id_v3"></a>
tbb_thread_v3::id&nbsp;</td><td class="memItemRight" valign="bottom"><b>thread_get_id_v3</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a58" doxytag="tbb::internal::thread_yield_v3"></a>
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>thread_yield_v3</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a59" doxytag="tbb::internal::thread_sleep_v3"></a>
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>thread_sleep_v3</b> (const <a class="el" href="a00237.html">tick_count::interval_t</a> &amp;i)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a60" doxytag="tbb::internal::operator=="></a>
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (tbb_thread_v3::id x, tbb_thread_v3::id y)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a61" doxytag="tbb::internal::operator!="></a>
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (tbb_thread_v3::id x, tbb_thread_v3::id y)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a62" doxytag="tbb::internal::operator<"></a>
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator&lt;</b> (tbb_thread_v3::id x, tbb_thread_v3::id y)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a63" doxytag="tbb::internal::operator<="></a>
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator&lt;=</b> (tbb_thread_v3::id x, tbb_thread_v3::id y)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a64" doxytag="tbb::internal::operator>"></a>
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator&gt;</b> (tbb_thread_v3::id x, tbb_thread_v3::id y)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a65" doxytag="tbb::internal::operator>="></a>
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator&gt;=</b> (tbb_thread_v3::id x, tbb_thread_v3::id y)</td></tr>

<tr><td colspan="2"><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00279.html#a0">NFS_MaxLineSize</a> = 128</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compile-time constant that is upper bound on cache line/sector size.  <a href="#a0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a5" doxytag="tbb::internal::IS_SERIAL"></a>
const unsigned char&nbsp;</td><td class="memItemRight" valign="bottom"><b>IS_SERIAL</b> = 0x1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a6" doxytag="tbb::internal::SERIAL_MODE_MASK"></a>
const unsigned char&nbsp;</td><td class="memItemRight" valign="bottom"><b>SERIAL_MODE_MASK</b> = 0x1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a7" doxytag="tbb::internal::VERSION_MASK"></a>
const unsigned char&nbsp;</td><td class="memItemRight" valign="bottom"><b>VERSION_MASK</b> = 0x7&lt;&lt;1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a8" doxytag="tbb::internal::CURRENT_VERSION"></a>
const unsigned char&nbsp;</td><td class="memItemRight" valign="bottom"><b>CURRENT_VERSION</b> = __TBB_PIPELINE_VERSION(3)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
INTERNAL 
<p>
INTERNAL 
<p>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="a14" doxytag="tbb::internal::intptr"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef std::ptrdiff_t <a class="el" href="a00279.html#a14">tbb::internal::intptr</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
A signed integral type big enough to hold a pointer. 
<p>
There's no guarantee by the C++ standard that a ptrdiff_t is really big enough, but it happens to be for all platforms of interest.     </td>
  </tr>
</table>
<a class="anchor" name="a4" doxytag="tbb::internal::reduction_context"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef char <a class="el" href="a00279.html#a4">tbb::internal::reduction_context</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
0 if root, 1 if a left child, 2 if a right child. 
<p>
Represented as a char, not enum, for compactness.     </td>
  </tr>
</table>
<a class="anchor" name="a11" doxytag="tbb::internal::reference_count"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef <a class="el" href="a00279.html#a14">intptr</a> <a class="el" href="a00279.html#a11">tbb::internal::reference_count</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
A reference count. 
<p>
Should always be non-negative. A signed type is used so that underflow can be detected.     </td>
  </tr>
</table>
<a class="anchor" name="a13" doxytag="tbb::internal::uintptr"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef size_t <a class="el" href="a00279.html#a13">tbb::internal::uintptr</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
An unsigned integral type big enough to hold a pointer. 
<p>
There's no guarantee by the C++ standard that a size_t is really big enough, but it happens to be for all platforms of interest.     </td>
  </tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="a42" doxytag="tbb::internal::allocate_via_handler_v3"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void* allocate_via_handler_v3           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">size_t&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>n</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Allocates memory using MallocHandler. 
<p>
The function uses scalable_malloc if scalable allocator is available and malloc if not     </td>
  </tr>
</table>
<a class="anchor" name="a41" doxytag="tbb::internal::deallocate_via_handler_v3"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void deallocate_via_handler_v3           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>p</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Deallocates memory using FreeHandler. 
<p>
The function uses scalable_free if scalable allocator is available and free if not     </td>
  </tr>
</table>
<a class="anchor" name="a18" doxytag="tbb::internal::NFS_Free"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void NFS_Free           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Free memory allocated by NFS_Allocate. 
<p>
Freeing a NULL pointer is allowed, but has no effect.     </td>
  </tr>
</table>
<hr><h2>Variable Documentation</h2>
<a class="anchor" name="a0" doxytag="tbb::internal::NFS_MaxLineSize"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">const size_t <a class="el" href="a00279.html#a0">tbb::internal::NFS_MaxLineSize</a> = 128          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Compile-time constant that is upper bound on cache line/sector size. 
<p>
It should be used only in situations where having a compile-time upper bound is more useful than a run-time exact answer.     </td>
  </tr>
</table>
<hr>
<p></p>
Copyright &copy; 2005-2008 Intel Corporation.  All Rights Reserved.
<p></p>
Intel, Pentium, Intel Xeon, Itanium, Intel XScale and VTune are
registered trademarks or trademarks of Intel Corporation or its
subsidiaries in the United States and other countries.
<p></p>
* Other names and brands may be claimed as the property of others.
