<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>concurrent_queue.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>concurrent_queue.h</h1><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment">    Copyright 2005-2008 Intel Corporation.  All Rights Reserved.</span>
00003 <span class="comment"></span>
00004 <span class="comment">    The source code contained or described herein and all documents related</span>
00005 <span class="comment">    to the source code ("Material") are owned by Intel Corporation or its</span>
00006 <span class="comment">    suppliers or licensors.  Title to the Material remains with Intel</span>
00007 <span class="comment">    Corporation or its suppliers and licensors.  The Material is protected</span>
00008 <span class="comment">    by worldwide copyright laws and treaty provisions.  No part of the</span>
00009 <span class="comment">    Material may be used, copied, reproduced, modified, published, uploaded,</span>
00010 <span class="comment">    posted, transmitted, distributed, or disclosed in any way without</span>
00011 <span class="comment">    Intel's prior express written permission.</span>
00012 <span class="comment"></span>
00013 <span class="comment">    No license under any patent, copyright, trade secret or other</span>
00014 <span class="comment">    intellectual property right is granted to or conferred upon you by</span>
00015 <span class="comment">    disclosure or delivery of the Materials, either expressly, by</span>
00016 <span class="comment">    implication, inducement, estoppel or otherwise.  Any license under such</span>
00017 <span class="comment">    intellectual property rights must be express and approved by Intel in</span>
00018 <span class="comment">    writing.</span>
00019 <span class="comment">*/</span>
00020 
00021 <span class="preprocessor">#ifndef __TBB_concurrent_queue_H</span>
00022 <span class="preprocessor"></span><span class="preprocessor">#define __TBB_concurrent_queue_H</span>
00023 <span class="preprocessor"></span>
00024 <span class="preprocessor">#include "tbb_stddef.h"</span>
00025 <span class="preprocessor">#include "cache_aligned_allocator.h"</span>
00026 <span class="preprocessor">#include "tbb_allocator.h"</span>
00027 <span class="preprocessor">#include &lt;new&gt;</span>
00028 
00029 <span class="keyword">namespace </span>tbb {
00030 
00031 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">class</span> A = cache_aligned_allocator&lt;T&gt; &gt; 
00032 <span class="keyword">class </span>concurrent_queue;
00033 
00035 <span class="keyword">namespace </span>internal {
00036 
00037 <span class="keyword">class </span>concurrent_queue_rep;
00038 <span class="keyword">class </span>concurrent_queue_iterator_rep;
00039 <span class="keyword">class </span>concurrent_queue_iterator_base_v3;
00040 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Value&gt; <span class="keyword">class </span>concurrent_queue_iterator;
00041 
00043 
<a name="l00045"></a><a class="code" href="a00178.html">00045</a> <span class="keyword">class </span><a class="code" href="a00178.html">concurrent_queue_base_v3</a>: <a class="code" href="a00200.html">no_copy</a> {
00047     concurrent_queue_rep* my_rep;
00048 
00049     <span class="keyword">friend</span> <span class="keyword">class </span>concurrent_queue_rep;
00050     <span class="keyword">friend</span> <span class="keyword">struct </span>micro_queue;
00051     <span class="keyword">friend</span> <span class="keyword">class </span>micro_queue_pop_finalizer;
00052     <span class="keyword">friend</span> <span class="keyword">class </span>concurrent_queue_iterator_rep;
00053     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="a00181.html">concurrent_queue_iterator_base_v3</a>;
00054 <span class="keyword">protected</span>:
<a name="l00056"></a><a class="code" href="a00179.html">00056</a>     <span class="keyword">struct </span><a class="code" href="a00179.html">page</a> {
00057         <a class="code" href="a00179.html">page</a>* next;
00058         <a class="code" href="a00279.html#a13">uintptr</a> mask; 
00059     };
00060 
<a name="l00062"></a><a class="code" href="a00178.html#p0">00062</a>     ptrdiff_t my_capacity;
00063    
<a name="l00065"></a><a class="code" href="a00178.html#p1">00065</a>     size_t items_per_page;
00066 
<a name="l00068"></a><a class="code" href="a00178.html#p2">00068</a>     size_t item_size;
00069 
00070 <span class="keyword">private</span>:
00071     <span class="keyword">virtual</span> <span class="keywordtype">void</span> copy_item( <a class="code" href="a00179.html">page</a>&amp; dst, size_t index, <span class="keyword">const</span> <span class="keywordtype">void</span>* src ) = 0;
00072     <span class="keyword">virtual</span> <span class="keywordtype">void</span> assign_and_destroy_item( <span class="keywordtype">void</span>* dst, <a class="code" href="a00179.html">page</a>&amp; src, size_t index ) = 0;
00073 <span class="keyword">protected</span>:
00074     <a class="code" href="a00178.html">concurrent_queue_base_v3</a>( size_t item_size );
00075     <span class="keyword">virtual</span> ~<a class="code" href="a00178.html">concurrent_queue_base_v3</a>();
00076 
00078     <span class="keywordtype">void</span> internal_push( <span class="keyword">const</span> <span class="keywordtype">void</span>* src );
00079 
00081     <span class="keywordtype">void</span> internal_pop( <span class="keywordtype">void</span>* dst );
00082 
00084     <span class="keywordtype">bool</span> internal_push_if_not_full( <span class="keyword">const</span> <span class="keywordtype">void</span>* src );
00085 
00087 
00088     <span class="keywordtype">bool</span> internal_pop_if_present( <span class="keywordtype">void</span>* dst );
00089 
00091     ptrdiff_t internal_size() <span class="keyword">const</span>;
00092 
00094     <span class="keywordtype">void</span> internal_set_capacity( ptrdiff_t capacity, size_t element_size );
00095 
00097     <span class="keyword">virtual</span> <a class="code" href="a00179.html">page</a> *allocate_page() = 0;
00098 
00100     <span class="keyword">virtual</span> <span class="keywordtype">void</span> deallocate_page( <a class="code" href="a00179.html">page</a> *p ) = 0;
00101 
00103     <span class="keywordtype">void</span> internal_finish_clear() ;
00104 
00106     <span class="keywordtype">void</span> internal_throw_exception() <span class="keyword">const</span>;
00107 };
00108 
00109 <span class="keyword">typedef</span> <a class="code" href="a00178.html">concurrent_queue_base_v3</a> <a class="code" href="a00178.html">concurrent_queue_base</a> ;
00110 
00112 
<a name="l00113"></a><a class="code" href="a00181.html">00113</a> <span class="keyword">class </span><a class="code" href="a00181.html">concurrent_queue_iterator_base_v3</a> {
00115 
00116     concurrent_queue_iterator_rep* my_rep;
00117 
00118     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;
00119     <span class="keyword">friend</span> <span class="keywordtype">bool</span> operator==( <span class="keyword">const</span> <a class="code" href="a00180.html">concurrent_queue_iterator&lt;C,T&gt;</a>&amp; i, <span class="keyword">const</span> <a class="code" href="a00180.html">concurrent_queue_iterator&lt;C,U&gt;</a>&amp; j );
00120 
00121     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;
00122     <span class="keyword">friend</span> <span class="keywordtype">bool</span> operator!=( <span class="keyword">const</span> <a class="code" href="a00180.html">concurrent_queue_iterator&lt;C,T&gt;</a>&amp; i, <span class="keyword">const</span> <a class="code" href="a00180.html">concurrent_queue_iterator&lt;C,U&gt;</a>&amp; j );
00123 <span class="keyword">protected</span>:
<a name="l00125"></a><a class="code" href="a00181.html#p0">00125</a>     <span class="keyword">mutable</span> <span class="keywordtype">void</span>* my_item;
00126 
<a name="l00128"></a><a class="code" href="a00181.html#b0">00128</a>     <a class="code" href="a00181.html">concurrent_queue_iterator_base_v3</a>() : my_rep(NULL), my_item(NULL) {}
00129 
<a name="l00131"></a><a class="code" href="a00181.html#b1">00131</a>     <a class="code" href="a00181.html">concurrent_queue_iterator_base_v3</a>( <span class="keyword">const</span> <a class="code" href="a00181.html">concurrent_queue_iterator_base_v3</a>&amp; i ) : my_rep(NULL), my_item(NULL) {
00132         assign(i);
00133     }
00134 
00136     <a class="code" href="a00181.html">concurrent_queue_iterator_base_v3</a>( <span class="keyword">const</span> concurrent_queue_base&amp; queue );
00137 
00139     <span class="keywordtype">void</span> assign( <span class="keyword">const</span> <a class="code" href="a00181.html">concurrent_queue_iterator_base_v3</a>&amp; i );
00140 
00142     <span class="keywordtype">void</span> advance();
00143 
00145     ~<a class="code" href="a00181.html">concurrent_queue_iterator_base_v3</a>();
00146 };
00147 
00148 <span class="keyword">typedef</span> concurrent_queue_iterator_base_v3 concurrent_queue_iterator_base;
00149 
00151 
00153 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Value&gt;
<a name="l00154"></a><a class="code" href="a00180.html">00154</a> <span class="keyword">class </span><a class="code" href="a00180.html">concurrent_queue_iterator</a>: <span class="keyword">public</span> <a class="code" href="a00181.html">concurrent_queue_iterator_base_v3</a> {
00155 <span class="preprocessor">#if !defined(_MSC_VER) || defined(__INTEL_COMPILER)</span>
00156 <span class="preprocessor"></span>    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">class</span> A&gt;
00157     <span class="keyword">friend</span> class ::tbb::concurrent_queue;
00158 <span class="preprocessor">#else</span>
00159 <span class="preprocessor"></span><span class="keyword">public</span>: <span class="comment">// workaround for MSVC</span>
00160 <span class="preprocessor">#endif </span>
00161 <span class="preprocessor"></span>
00162     <a class="code" href="a00180.html">concurrent_queue_iterator</a>( <span class="keyword">const</span> concurrent_queue_base&amp; queue ) :
00163         <a class="code" href="a00181.html">concurrent_queue_iterator_base_v3</a>(queue)
00164     {
00165     }
00166 <span class="keyword">public</span>:
00167     <a class="code" href="a00180.html">concurrent_queue_iterator</a>() {}
00168 
<a name="l00171"></a><a class="code" href="a00180.html#a1">00171</a>     <a class="code" href="a00180.html">concurrent_queue_iterator</a>( <span class="keyword">const</span> <a class="code" href="a00180.html">concurrent_queue_iterator&lt;Container,typename Container::value_type&gt;</a>&amp; other ) :
00172         <a class="code" href="a00181.html">concurrent_queue_iterator_base_v3</a>(other)
00173     {}
00174 
<a name="l00176"></a><a class="code" href="a00180.html#a2">00176</a>     <a class="code" href="a00180.html">concurrent_queue_iterator</a>&amp; operator=( <span class="keyword">const</span> <a class="code" href="a00180.html">concurrent_queue_iterator</a>&amp; other ) {
00177         assign(other);
00178         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00179     }
00180 
<a name="l00182"></a><a class="code" href="a00180.html#a3">00182</a>     Value&amp; operator*()<span class="keyword"> const </span>{
00183         <span class="keywordflow">return</span> *static_cast&lt;Value*&gt;(my_item);
00184     }
00185 
00186     Value* operator-&gt;()<span class="keyword"> const </span>{<span class="keywordflow">return</span> &amp;operator*();}
00187 
<a name="l00189"></a><a class="code" href="a00180.html#a5">00189</a>     <a class="code" href="a00180.html">concurrent_queue_iterator</a>&amp; operator++() {
00190         advance();
00191         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00192     }
00193 
<a name="l00195"></a><a class="code" href="a00180.html#a6">00195</a>     Value* operator++(<span class="keywordtype">int</span>) {
00196         Value* result = &amp;operator*();
00197         operator++();
00198         <span class="keywordflow">return</span> result;
00199     }
00200 }; <span class="comment">// concurrent_queue_iterator</span>
00201 
00202 
00203 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;
00204 <span class="keywordtype">bool</span> operator==( <span class="keyword">const</span> concurrent_queue_iterator&lt;C,T&gt;&amp; i, <span class="keyword">const</span> concurrent_queue_iterator&lt;C,U&gt;&amp; j ) {
00205     <span class="keywordflow">return</span> i.my_item==j.my_item;
00206 }
00207 
00208 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;
00209 <span class="keywordtype">bool</span> operator!=( <span class="keyword">const</span> concurrent_queue_iterator&lt;C,T&gt;&amp; i, <span class="keyword">const</span> concurrent_queue_iterator&lt;C,U&gt;&amp; j ) {
00210     <span class="keywordflow">return</span> i.my_item!=j.my_item;
00211 }
00212 
00213 } <span class="comment">// namespace internal;</span>
00214 
00216 
00218 
00221 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">class</span> A&gt;
<a name="l00222"></a><a class="code" href="a00177.html">00222</a> <span class="keyword">class </span><a class="code" href="a00177.html">concurrent_queue</a>: <span class="keyword">public</span> internal::concurrent_queue_base_v3 {
00223     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Value&gt; <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="a00180.html">internal::concurrent_queue_iterator</a>;
00224 
00226     <span class="keyword">typedef</span> <span class="keyword">typename</span> A::template rebind&lt;char&gt;::other page_allocator_type;
00227     page_allocator_type my_allocator;
00228 
00230     <span class="keyword">class </span>destroyer {
00231         T&amp; my_value;
00232     <span class="keyword">public</span>:
00233         destroyer( T&amp; value ) : my_value(value) {}
00234         ~destroyer() {my_value.~T();}          
00235     };
00236 
00237     T&amp; get_ref( page&amp; page, size_t index ) {
00238         __TBB_ASSERT( index&lt;items_per_page, NULL );
00239         <span class="keywordflow">return</span> static_cast&lt;T*&gt;(static_cast&lt;void*&gt;(&amp;page+1))[index];
00240     }
00241 
00242     <span class="comment">/*override*/</span> <span class="keyword">virtual</span> <span class="keywordtype">void</span> copy_item( page&amp; dst, size_t index, <span class="keyword">const</span> <span class="keywordtype">void</span>* src ) {
00243         <span class="keyword">new</span>( &amp;get_ref(dst,index) ) T(*static_cast&lt;const T*&gt;(src)); 
00244     }
00245 
00246     <span class="comment">/*override*/</span> <span class="keyword">virtual</span> <span class="keywordtype">void</span> assign_and_destroy_item( <span class="keywordtype">void</span>* dst, page&amp; src, size_t index ) {
00247         T&amp; from = get_ref(src,index);
00248         destroyer d(from);
00249         *static_cast&lt;T*&gt;(dst) = from;
00250     }
00251 
00252     <span class="comment">/*overide*/</span> <span class="keyword">virtual</span> page *allocate_page() {
00253         size_t n = <span class="keyword">sizeof</span>(page) + items_per_page*item_size;
00254         page *p = reinterpret_cast&lt;page*&gt;(my_allocator.allocate( n ));
00255         <span class="keywordflow">if</span>( !p ) internal_throw_exception(); 
00256         <span class="keywordflow">return</span> p;
00257     }
00258     
00259     <span class="comment">/*override*/</span> <span class="keyword">virtual</span> <span class="keywordtype">void</span> deallocate_page( page *p ) {
00260         size_t n = <span class="keyword">sizeof</span>(page) + items_per_page*item_size;
00261         my_allocator.deallocate( reinterpret_cast&lt;char*&gt;(p), n );
00262     }
00263 
00264 <span class="keyword">public</span>:
<a name="l00266"></a><a class="code" href="a00177.html#w0">00266</a>     <span class="keyword">typedef</span> T value_type;
00267 
<a name="l00269"></a><a class="code" href="a00177.html#w1">00269</a>     <span class="keyword">typedef</span> A allocator_type;
00270 
<a name="l00272"></a><a class="code" href="a00177.html#w2">00272</a>     <span class="keyword">typedef</span> T&amp; reference;
00273 
<a name="l00275"></a><a class="code" href="a00177.html#w3">00275</a>     <span class="keyword">typedef</span> <span class="keyword">const</span> T&amp; const_reference;
00276 
00278 
<a name="l00280"></a><a class="code" href="a00177.html#w4">00280</a>     <span class="keyword">typedef</span> std::ptrdiff_t size_type;
00281 
<a name="l00283"></a><a class="code" href="a00177.html#w5">00283</a>     <span class="keyword">typedef</span> std::ptrdiff_t difference_type;
00284 
<a name="l00286"></a><a class="code" href="a00177.html#a0">00286</a>     <a class="code" href="a00177.html">concurrent_queue</a>(<span class="keyword">const</span> allocator_type  &amp;a = allocator_type()) : 
00287         concurrent_queue_base_v3( sizeof(T) )
00288             , my_allocator( a )
00289     {
00290     }
00291 
00293     ~<a class="code" href="a00177.html">concurrent_queue</a>();
00294 
<a name="l00296"></a><a class="code" href="a00177.html#a2">00296</a>     <span class="keywordtype">void</span> push( <span class="keyword">const</span> T&amp; source ) {
00297         internal_push( &amp;source );
00298     }
00299 
00301 
<a name="l00302"></a><a class="code" href="a00177.html#a3">00302</a>     <span class="keywordtype">void</span> pop( T&amp; destination ) {
00303         internal_pop( &amp;destination );
00304     }
00305 
00307 
<a name="l00309"></a><a class="code" href="a00177.html#a4">00309</a>     <span class="keywordtype">bool</span> push_if_not_full( <span class="keyword">const</span> T&amp; source ) {
00310         <span class="keywordflow">return</span> internal_push_if_not_full( &amp;source );
00311     }
00312 
00314 
<a name="l00316"></a><a class="code" href="a00177.html#a5">00316</a>     <span class="keywordtype">bool</span> pop_if_present( T&amp; destination ) {
00317         <span class="keywordflow">return</span> internal_pop_if_present( &amp;destination );
00318     }
00319 
00321 
<a name="l00324"></a><a class="code" href="a00177.html#a6">00324</a>     size_type size()<span class="keyword"> const </span>{<span class="keywordflow">return</span> internal_size();}
00325 
<a name="l00327"></a><a class="code" href="a00177.html#a7">00327</a>     <span class="keywordtype">bool</span> empty()<span class="keyword"> const </span>{<span class="keywordflow">return</span> size()&lt;=0;}
00328 
<a name="l00330"></a><a class="code" href="a00177.html#a8">00330</a>     size_type capacity()<span class="keyword"> const </span>{
00331         <span class="keywordflow">return</span> my_capacity;
00332     }
00333 
00335 
<a name="l00337"></a><a class="code" href="a00177.html#a9">00337</a>     <span class="keywordtype">void</span> set_capacity( size_type capacity ) {
00338         internal_set_capacity( capacity, <span class="keyword">sizeof</span>(T) );
00339     }
00340 
<a name="l00342"></a><a class="code" href="a00177.html#a10">00342</a>     allocator_type get_allocator()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> this-&gt;my_allocator; }
00343 
00345     <span class="keywordtype">void</span> clear() ;
00346 
00347     <span class="keyword">typedef</span> <a class="code" href="a00180.html">internal::concurrent_queue_iterator&lt;concurrent_queue,T&gt;</a> iterator;
00348     <span class="keyword">typedef</span> <a class="code" href="a00180.html">internal::concurrent_queue_iterator&lt;concurrent_queue,const T&gt;</a> const_iterator;
00349 
00350     <span class="comment">//------------------------------------------------------------------------</span>
00351     <span class="comment">// The iterators are intended only for debugging.  They are slow and not thread safe.</span>
00352     <span class="comment">//------------------------------------------------------------------------</span>
00353     iterator begin() {<span class="keywordflow">return</span> iterator(*<span class="keyword">this</span>);}
00354     iterator end() {<span class="keywordflow">return</span> iterator();}
00355     const_iterator begin()<span class="keyword"> const </span>{<span class="keywordflow">return</span> const_iterator(*<span class="keyword">this</span>);}
00356     const_iterator end()<span class="keyword"> const </span>{<span class="keywordflow">return</span> const_iterator();}
00357     
00358 }; 
00359 
00360 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">class</span> A&gt;
<a name="l00361"></a><a class="code" href="a00177.html#a1">00361</a> <a class="code" href="a00177.html">concurrent_queue&lt;T,A&gt;::~concurrent_queue</a>() {
00362     <a class="code" href="a00177.html#a11">clear</a>();
00363 }
00364 
00365 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">class</span> A&gt;
<a name="l00366"></a><a class="code" href="a00177.html#a11">00366</a> <span class="keywordtype">void</span> <a class="code" href="a00177.html">concurrent_queue&lt;T,A&gt;::clear</a>() {
00367     <span class="keywordflow">while</span>( !<a class="code" href="a00177.html#a7">empty</a>() ) {
00368         T value;
00369         <a class="code" href="a00178.html#b5">internal_pop_if_present</a>(&amp;value);
00370     }
00371     <a class="code" href="a00178.html#b10">internal_finish_clear</a>();
00372 }
00373 
00374 } <span class="comment">// namespace tbb</span>
00375 
00376 <span class="preprocessor">#endif </span><span class="comment">/* __TBB_concurrent_queue_H */</span>
</pre></div><hr>
<p></p>
Copyright &copy; 2005-2008 Intel Corporation.  All Rights Reserved.
<p></p>
Intel, Pentium, Intel Xeon, Itanium, Intel XScale and VTune are
registered trademarks or trademarks of Intel Corporation or its
subsidiaries in the United States and other countries.
<p></p>
* Other names and brands may be claimed as the property of others.
