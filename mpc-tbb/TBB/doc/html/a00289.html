<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>concurrent_hash_map.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>concurrent_hash_map.h</h1><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment">    Copyright 2005-2008 Intel Corporation.  All Rights Reserved.</span>
00003 <span class="comment"></span>
00004 <span class="comment">    The source code contained or described herein and all documents related</span>
00005 <span class="comment">    to the source code ("Material") are owned by Intel Corporation or its</span>
00006 <span class="comment">    suppliers or licensors.  Title to the Material remains with Intel</span>
00007 <span class="comment">    Corporation or its suppliers and licensors.  The Material is protected</span>
00008 <span class="comment">    by worldwide copyright laws and treaty provisions.  No part of the</span>
00009 <span class="comment">    Material may be used, copied, reproduced, modified, published, uploaded,</span>
00010 <span class="comment">    posted, transmitted, distributed, or disclosed in any way without</span>
00011 <span class="comment">    Intel's prior express written permission.</span>
00012 <span class="comment"></span>
00013 <span class="comment">    No license under any patent, copyright, trade secret or other</span>
00014 <span class="comment">    intellectual property right is granted to or conferred upon you by</span>
00015 <span class="comment">    disclosure or delivery of the Materials, either expressly, by</span>
00016 <span class="comment">    implication, inducement, estoppel or otherwise.  Any license under such</span>
00017 <span class="comment">    intellectual property rights must be express and approved by Intel in</span>
00018 <span class="comment">    writing.</span>
00019 <span class="comment">*/</span>
00020 
00021 <span class="preprocessor">#ifndef __TBB_concurrent_hash_map_H</span>
00022 <span class="preprocessor"></span><span class="preprocessor">#define __TBB_concurrent_hash_map_H</span>
00023 <span class="preprocessor"></span>
00024 <span class="preprocessor">#include &lt;stdexcept&gt;</span>
00025 <span class="preprocessor">#include &lt;iterator&gt;</span>
00026 <span class="preprocessor">#include &lt;utility&gt;</span>      <span class="comment">// Need std::pair from here</span>
00027 <span class="preprocessor">#include "tbb_stddef.h"</span>
00028 <span class="preprocessor">#include "cache_aligned_allocator.h"</span>
00029 <span class="preprocessor">#include "tbb_allocator.h"</span>
00030 <span class="preprocessor">#include "spin_rw_mutex.h"</span>
00031 <span class="preprocessor">#include "atomic.h"</span>
00032 <span class="preprocessor">#include "aligned_space.h"</span>
00033 <span class="preprocessor">#if TBB_PERFORMANCE_WARNINGS</span>
00034 <span class="preprocessor"></span><span class="preprocessor">#include &lt;typeinfo&gt;</span>
00035 <span class="preprocessor">#endif</span>
00036 <span class="preprocessor"></span>
00037 <span class="keyword">namespace </span>tbb {
00038 
00039 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare, <span class="keyword">typename</span> A = tbb_allocator&lt;std::pair&lt;Key, T&gt; &gt; &gt;
00040 <span class="keyword">class </span>concurrent_hash_map;
00041 
00043 <span class="keyword">namespace </span>internal {
<a name="l00045"></a><a class="code" href="a00195.html">00045</a>     <span class="keyword">class </span><a class="code" href="a00195.html">hash_map_base</a> {
00046     <span class="keyword">public</span>:
00047         <span class="comment">// Mutex types for each layer of the container</span>
00048         <span class="keyword">typedef</span> <a class="code" href="a00219.html">spin_rw_mutex</a> <a class="code" href="a00219.html">node_mutex_t</a>;
00049         <span class="keyword">typedef</span> <a class="code" href="a00219.html">spin_rw_mutex</a> <a class="code" href="a00219.html">chain_mutex_t</a>;
00050         <span class="keyword">typedef</span> <a class="code" href="a00219.html">spin_rw_mutex</a> <a class="code" href="a00219.html">segment_mutex_t</a>;
00051 
<a name="l00053"></a><a class="code" href="a00195.html#w3">00053</a>         <span class="keyword">typedef</span> size_t <a class="code" href="a00195.html#w3">hashcode_t</a>;
<a name="l00055"></a><a class="code" href="a00195.html#s0">00055</a>         <span class="keyword">static</span> <span class="keyword">const</span> size_t n_segment_bits = 6;
<a name="l00057"></a><a class="code" href="a00195.html#s1">00057</a>         <span class="keyword">static</span> <span class="keyword">const</span> size_t n_segment = size_t(1)&lt;&lt;n_segment_bits; 
<a name="l00059"></a><a class="code" href="a00195.html#s2">00059</a>         <span class="keyword">static</span> <span class="keyword">const</span> size_t max_physical_size = size_t(1)&lt;&lt;(8*<span class="keyword">sizeof</span>(hashcode_t)-n_segment_bits);
00060     };
00061 
00062     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator&gt;
00063     <span class="keyword">class </span><a class="code" href="a00197.html">hash_map_range</a>;
00064 
00065     <span class="keyword">struct </span>hash_map_segment_base {
00067         <a class="code" href="a00219.html">hash_map_base::segment_mutex_t</a> my_mutex;
00068 
00069         <span class="comment">// Number of nodes</span>
00070         <a class="code" href="a00165.html">atomic&lt;size_t&gt;</a> my_logical_size;
00071 
00072         <span class="comment">// Size of chains</span>
00074 <span class="comment"></span>        size_t my_physical_size;
00075 
00077 
00078         <span class="keywordtype">bool</span> internal_grow_predicate() <span class="keyword">const</span>;
00079     };
00080 
00082 
00084     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Value&gt;
<a name="l00085"></a><a class="code" href="a00196.html">00085</a>     <span class="keyword">class </span><a class="code" href="a00196.html">hash_map_iterator</a>
00086 #if defined(_WIN64) &amp;&amp; defined(_MSC_VER) 
00087         <span class="comment">// Ensure that Microsoft's internal template function _Val_type works correctly.</span>
00088         : public std::iterator&lt;std::forward_iterator_tag,Value&gt;
00089 #endif <span class="comment">/* defined(_WIN64) &amp;&amp; defined(_MSC_VER) */</span>
00090     {
00091         <span class="keyword">typedef</span> <span class="keyword">typename</span> Container::node node;
00092         <span class="keyword">typedef</span> <span class="keyword">typename</span> Container::chain chain;
00093 
00095         Container* my_table;
00096 
00098         node* my_node;
00099 
00101         size_t my_array_index;
00102 
00104         size_t my_segment_index;
00105 
00106         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;
00107         <span class="keyword">friend</span> <span class="keywordtype">bool</span> operator==( <span class="keyword">const</span> <a class="code" href="a00196.html">hash_map_iterator&lt;C,T&gt;</a>&amp; i, <span class="keyword">const</span> <a class="code" href="a00196.html">hash_map_iterator&lt;C,U&gt;</a>&amp; j );
00108 
00109         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;
00110         <span class="keyword">friend</span> <span class="keywordtype">bool</span> operator!=( <span class="keyword">const</span> <a class="code" href="a00196.html">hash_map_iterator&lt;C,T&gt;</a>&amp; i, <span class="keyword">const</span> <a class="code" href="a00196.html">hash_map_iterator&lt;C,U&gt;</a>&amp; j );
00111 
00112         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;
00113         <span class="keyword">friend</span> ptrdiff_t operator-( <span class="keyword">const</span> <a class="code" href="a00196.html">hash_map_iterator&lt;C,T&gt;</a>&amp; i, <span class="keyword">const</span> <a class="code" href="a00196.html">hash_map_iterator&lt;C,U&gt;</a>&amp; j );
00114     
00115         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> U&gt;
00116         <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="a00196.html">internal::hash_map_iterator</a>;
00117 
00118         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> I&gt;
00119         <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="a00197.html">internal::hash_map_range</a>;
00120 
00121         <span class="keywordtype">void</span> advance_to_next_node() {
00122             size_t i = my_array_index+1;
00123             <span class="keywordflow">do</span> {
00124                 <span class="keywordflow">while</span>( i&lt;my_table-&gt;my_segment[my_segment_index].my_physical_size ) {
00125                     my_node = my_table-&gt;my_segment[my_segment_index].my_array[i].node_list;
00126                     <span class="keywordflow">if</span>( my_node ) <span class="keywordflow">goto</span> done;
00127                     ++i;
00128                 }
00129                 i = 0;
00130             } <span class="keywordflow">while</span>( ++my_segment_index&lt;my_table-&gt;n_segment );
00131         done:
00132             my_array_index = i;
00133         }
00134 <span class="preprocessor">#if !defined(_MSC_VER) || defined(__INTEL_COMPILER)</span>
00135 <span class="preprocessor"></span>        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare, <span class="keyword">typename</span> A&gt;
00136         <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="a00174.html">tbb::concurrent_hash_map</a>;
00137 <span class="preprocessor">#else</span>
00138 <span class="preprocessor"></span>    <span class="keyword">public</span>: <span class="comment">// workaround</span>
00139 <span class="preprocessor">#endif</span>
00140 <span class="preprocessor"></span>        <a class="code" href="a00196.html">hash_map_iterator</a>( <span class="keyword">const</span> Container&amp; table, size_t segment_index, size_t array_index=0, node* b=NULL );
00141     <span class="keyword">public</span>:
<a name="l00143"></a><a class="code" href="a00196.html#a0">00143</a>         <a class="code" href="a00196.html">hash_map_iterator</a>() {}
00144         <a class="code" href="a00196.html">hash_map_iterator</a>( <span class="keyword">const</span> <a class="code" href="a00196.html">hash_map_iterator&lt;Container,typename Container::value_type&gt;</a>&amp; other ) :
00145             my_table(other.my_table),
00146             my_node(other.my_node),
00147             my_array_index(other.my_array_index),
00148             my_segment_index(other.my_segment_index)
00149         {}
00150         Value&amp; operator*()<span class="keyword"> const </span>{
00151             __TBB_ASSERT( my_node, <span class="stringliteral">"iterator uninitialized or at end of container?"</span> );
00152             <span class="keywordflow">return</span> my_node-&gt;item;
00153         }
00154         Value* operator-&gt;()<span class="keyword"> const </span>{<span class="keywordflow">return</span> &amp;operator*();}
00155         hash_map_iterator&amp; operator++();
00156         
<a name="l00158"></a><a class="code" href="a00196.html#a5">00158</a>         Value* operator++(<span class="keywordtype">int</span>) {
00159             Value* result = &amp;operator*();
00160             operator++();
00161             <span class="keywordflow">return</span> result;
00162         }
00163 
00164         <span class="comment">// STL support</span>
00165 
00166         <span class="keyword">typedef</span> ptrdiff_t difference_type;
00167         <span class="keyword">typedef</span> Value value_type;
00168         <span class="keyword">typedef</span> Value* pointer;
00169         <span class="keyword">typedef</span> Value&amp; reference;
00170         <span class="keyword">typedef</span> <span class="keyword">const</span> Value&amp; const_reference;
00171         <span class="keyword">typedef</span> std::forward_iterator_tag iterator_category;
00172     };
00173 
00174     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Value&gt;
00175     hash_map_iterator&lt;Container,Value&gt;::hash_map_iterator( <span class="keyword">const</span> Container&amp; table, size_t segment_index, size_t array_index, node* b ) : 
00176         my_table(const_cast&lt;Container*&gt;(&amp;table)),
00177         my_node(b),
00178         my_array_index(array_index),
00179         my_segment_index(segment_index)
00180     {
00181         <span class="keywordflow">if</span>( segment_index&lt;my_table-&gt;n_segment ) {
00182             <span class="keywordflow">if</span>( !my_node ) {
00183                 chain* first_chain = my_table-&gt;my_segment[segment_index].my_array;
00184                 <span class="keywordflow">if</span>( first_chain ) my_node = first_chain[my_array_index].node_list;
00185             }
00186             <span class="keywordflow">if</span>( !my_node ) advance_to_next_node();
00187         }
00188     }
00189 
00190     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Value&gt;
00191     hash_map_iterator&lt;Container,Value&gt;&amp; hash_map_iterator&lt;Container,Value&gt;::operator++() {
00192         my_node=my_node-&gt;next;
00193         <span class="keywordflow">if</span>( !my_node ) advance_to_next_node();
00194         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00195     }
00196 
00197     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;
00198     <span class="keywordtype">bool</span> operator==( <span class="keyword">const</span> hash_map_iterator&lt;Container,T&gt;&amp; i, <span class="keyword">const</span> hash_map_iterator&lt;Container,U&gt;&amp; j ) {
00199         <span class="keywordflow">return</span> i.<a class="code" href="a00196.html#r1">my_node</a>==j.<a class="code" href="a00196.html#r1">my_node</a>;
00200     }
00201 
00202     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;
00203     <span class="keywordtype">bool</span> operator!=( <span class="keyword">const</span> hash_map_iterator&lt;Container,T&gt;&amp; i, <span class="keyword">const</span> hash_map_iterator&lt;Container,U&gt;&amp; j ) {
00204         <span class="keywordflow">return</span> i.<a class="code" href="a00196.html#r1">my_node</a>!=j.<a class="code" href="a00196.html#r1">my_node</a>;
00205     }
00206 
00208 
00209     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator&gt;
<a name="l00210"></a><a class="code" href="a00197.html">00210</a>     <span class="keyword">class </span><a class="code" href="a00197.html">hash_map_range</a> {
00211     <span class="keyword">private</span>:
00212         Iterator my_begin;
00213         Iterator my_end;
00214         <span class="keyword">mutable</span> Iterator my_midpoint;
00215         size_t my_grainsize;
00217         <span class="keywordtype">void</span> set_midpoint() <span class="keyword">const</span>;
00218         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="a00197.html">hash_map_range</a>;
00219     <span class="keyword">public</span>:
<a name="l00221"></a><a class="code" href="a00197.html#w0">00221</a>         <span class="keyword">typedef</span> std::size_t size_type;
00222         <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::value_type value_type;
00223         <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::reference reference;
00224         <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::const_reference const_reference;
00225         <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::difference_type difference_type;
00226         <span class="keyword">typedef</span> Iterator iterator;
00227 
<a name="l00229"></a><a class="code" href="a00197.html#a0">00229</a>         <span class="keywordtype">bool</span> empty()<span class="keyword"> const </span>{<span class="keywordflow">return</span> my_begin==my_end;}
00230 
<a name="l00232"></a><a class="code" href="a00197.html#a1">00232</a>         <span class="keywordtype">bool</span> is_divisible()<span class="keyword"> const </span>{
00233             <span class="keywordflow">return</span> my_midpoint!=my_end;
00234         }
<a name="l00236"></a><a class="code" href="a00197.html#a2">00236</a>         <a class="code" href="a00197.html">hash_map_range</a>( <a class="code" href="a00197.html">hash_map_range</a>&amp; r, <a class="code" href="a00221.html">split</a> ) : 
00237             my_end(r.my_end),
00238             my_grainsize(r.my_grainsize)
00239         {
00240             r.<a class="code" href="a00197.html#r1">my_end</a> = my_begin = r.<a class="code" href="a00197.html#r2">my_midpoint</a>;
00241             set_midpoint();
00242             r.<a class="code" href="a00197.html#d0">set_midpoint</a>();
00243         }
00245         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;
<a name="l00246"></a><a class="code" href="a00197.html#a3">00246</a>         <a class="code" href="a00197.html">hash_map_range</a>( <a class="code" href="a00197.html">hash_map_range&lt;U&gt;</a>&amp; r) : 
00247             my_begin(r.my_begin),
00248             my_end(r.my_end),
00249             my_midpoint(r.my_midpoint),
00250             my_grainsize(r.my_grainsize)
00251         {}
<a name="l00253"></a><a class="code" href="a00197.html#a4">00253</a>         <a class="code" href="a00197.html">hash_map_range</a>( <span class="keyword">const</span> Iterator&amp; begin_, <span class="keyword">const</span> Iterator&amp; end_, size_type grainsize = 1 ) : 
00254             my_begin(begin_), 
00255             my_end(end_), 
00256             my_grainsize(grainsize) 
00257         {
00258             set_midpoint();
00259             __TBB_ASSERT( grainsize&gt;0, <span class="stringliteral">"grainsize must be positive"</span> );
00260         }
00261         <span class="keyword">const</span> Iterator&amp; begin()<span class="keyword"> const </span>{<span class="keywordflow">return</span> my_begin;}
00262         <span class="keyword">const</span> Iterator&amp; end()<span class="keyword"> const </span>{<span class="keywordflow">return</span> my_end;}
<a name="l00264"></a><a class="code" href="a00197.html#a7">00264</a>         size_type grainsize()<span class="keyword"> const </span>{<span class="keywordflow">return</span> my_grainsize;}
00265     };
00266 
00267     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator&gt;
00268     <span class="keywordtype">void</span> hash_map_range&lt;Iterator&gt;::set_midpoint()<span class="keyword"> const </span>{
00269         size_t n = my_end.my_segment_index-my_begin.my_segment_index;
00270         <span class="keywordflow">if</span>( n&gt;1 || (n==1 &amp;&amp; my_end.my_array_index&gt;0) ) {
00271             <span class="comment">// Split by groups of segments</span>
00272             my_midpoint = Iterator(*my_begin.my_table,(my_end.my_segment_index+my_begin.my_segment_index)/2u);
00273         } <span class="keywordflow">else</span> {
00274             <span class="comment">// Split by groups of nodes</span>
00275             size_t m = my_end.my_array_index-my_begin.my_array_index;
00276             <span class="keywordflow">if</span>( m&gt;my_grainsize ) {
00277                 my_midpoint = Iterator(*my_begin.my_table,my_begin.my_segment_index,m/2u);
00278             } <span class="keywordflow">else</span> {
00279                 my_midpoint = my_end;
00280             }
00281         }
00282         __TBB_ASSERT( my_midpoint.my_segment_index&lt;=my_begin.my_table-&gt;n_segment, NULL );
00283     }  
00284 } <span class="comment">// namespace internal</span>
00286 <span class="comment"></span>
00288 
00313 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare, <span class="keyword">typename</span> A&gt;
<a name="l00314"></a><a class="code" href="a00174.html">00314</a> <span class="keyword">class </span><a class="code" href="a00174.html">concurrent_hash_map</a> : <span class="keyword">protected</span> internal::hash_map_base {
00315     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Value&gt;
00316     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="a00196.html">internal::hash_map_iterator</a>;
00317 
00318     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> I&gt;
00319     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="a00197.html">internal::hash_map_range</a>;
00320 
00321     <span class="keyword">struct </span>node;
00322     <span class="keyword">friend</span> <span class="keyword">struct </span>node;
00323     <span class="keyword">typedef</span> <span class="keyword">typename</span> A::template rebind&lt;node&gt;::other node_allocator_type;
00324 
00325 <span class="keyword">public</span>:
00326     <span class="keyword">class </span><a class="code" href="a00176.html">const_accessor</a>;
00327     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="a00176.html">const_accessor</a>;
00328     <span class="keyword">class </span><a class="code" href="a00175.html">accessor</a>;
00329 
00330     <span class="keyword">typedef</span> Key key_type;
00331     <span class="keyword">typedef</span> T mapped_type;
00332     <span class="keyword">typedef</span> std::pair&lt;const Key,T&gt; value_type;
00333     <span class="keyword">typedef</span> size_t size_type;
00334     <span class="keyword">typedef</span> ptrdiff_t difference_type;
00335     <span class="keyword">typedef</span> value_type *pointer;
00336     <span class="keyword">typedef</span> <span class="keyword">const</span> value_type *const_pointer;
00337     <span class="keyword">typedef</span> value_type &amp;reference;
00338     <span class="keyword">typedef</span> <span class="keyword">const</span> value_type &amp;const_reference;
00339     <span class="keyword">typedef</span> <a class="code" href="a00196.html">internal::hash_map_iterator&lt;concurrent_hash_map,value_type&gt;</a> <a class="code" href="a00196.html">iterator</a>;
00340     <span class="keyword">typedef</span> <a class="code" href="a00196.html">internal::hash_map_iterator&lt;concurrent_hash_map,const value_type&gt;</a> <a class="code" href="a00196.html">const_iterator</a>;
00341     <span class="keyword">typedef</span> <a class="code" href="a00197.html">internal::hash_map_range&lt;iterator&gt;</a> <a class="code" href="a00197.html">range_type</a>;
00342     <span class="keyword">typedef</span> <a class="code" href="a00197.html">internal::hash_map_range&lt;const_iterator&gt;</a> <a class="code" href="a00197.html">const_range_type</a>;
00343     <span class="keyword">typedef</span> A allocator_type;
00344 
<a name="l00346"></a><a class="code" href="a00176.html">00346</a>     <span class="keyword">class </span><a class="code" href="a00176.html">const_accessor</a> {
00347         <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="a00174.html">concurrent_hash_map</a>;
00348         <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="a00175.html">accessor</a>;
00349         <span class="keywordtype">void</span> operator=( <span class="keyword">const</span> <a class="code" href="a00175.html">accessor</a>&amp; ) <span class="keyword">const</span>; <span class="comment">// Deny access</span>
00350         <a class="code" href="a00176.html">const_accessor</a>( <span class="keyword">const</span> <a class="code" href="a00175.html">accessor</a>&amp; );       <span class="comment">// Deny access</span>
00351     <span class="keyword">public</span>:
<a name="l00353"></a><a class="code" href="a00176.html#w0">00353</a>         <span class="keyword">typedef</span> <span class="keyword">const</span> std::pair&lt;const Key,T&gt; value_type;
00354 
<a name="l00356"></a><a class="code" href="a00176.html#a0">00356</a>         <span class="keywordtype">bool</span> empty()<span class="keyword"> const </span>{<span class="keywordflow">return</span> !my_node;}
00357 
<a name="l00359"></a><a class="code" href="a00176.html#a1">00359</a>         <span class="keywordtype">void</span> <a class="code" href="a00278.html#a37a2">release</a>() {
00360             <span class="keywordflow">if</span>( my_node ) {
00361                 my_lock.release();
00362                 my_node = NULL;
00363             }
00364         }
00365 
<a name="l00367"></a><a class="code" href="a00176.html#a2">00367</a>         const_reference operator*()<span class="keyword"> const </span>{
00368             __TBB_ASSERT( my_node, <span class="stringliteral">"attempt to dereference empty accessor"</span> );
00369             <span class="keywordflow">return</span> my_node-&gt;item;
00370         }
00371 
<a name="l00373"></a><a class="code" href="a00176.html#a3">00373</a>         const_pointer operator-&gt;()<span class="keyword"> const </span>{
00374             <span class="keywordflow">return</span> &amp;operator*();
00375         }
00376 
<a name="l00378"></a><a class="code" href="a00176.html#a4">00378</a>         <a class="code" href="a00176.html">const_accessor</a>() : my_node(NULL) {}
00379 
<a name="l00381"></a><a class="code" href="a00176.html#a5">00381</a>         ~<a class="code" href="a00176.html">const_accessor</a>() {
00382             my_node = NULL; <span class="comment">// my_lock.release() is called in scoped_lock destructor</span>
00383         }
00384     <span class="keyword">private</span>:
00385         node* my_node;
00386         node_mutex_t::scoped_lock my_lock;
00387         hashcode_t my_hash;
00388     };
00389 
<a name="l00391"></a><a class="code" href="a00175.html">00391</a>     <span class="keyword">class </span><a class="code" href="a00175.html">accessor</a>: <span class="keyword">public</span> <a class="code" href="a00176.html">const_accessor</a> {
00392     <span class="keyword">public</span>:
<a name="l00394"></a><a class="code" href="a00175.html#w0">00394</a>         <span class="keyword">typedef</span> std::pair&lt;const Key,T&gt; value_type;
00395 
<a name="l00397"></a><a class="code" href="a00175.html#a0">00397</a>         reference operator*()<span class="keyword"> const </span>{
00398             __TBB_ASSERT( this-&gt;my_node, <span class="stringliteral">"attempt to dereference empty accessor"</span> );
00399             <span class="keywordflow">return</span> this-&gt;my_node-&gt;item;
00400         }
00401 
<a name="l00403"></a><a class="code" href="a00175.html#a1">00403</a>         pointer operator-&gt;()<span class="keyword"> const </span>{
00404             <span class="keywordflow">return</span> &amp;operator*();
00405         }       
00406     };
00407 
<a name="l00409"></a><a class="code" href="a00174.html#a0">00409</a>     <a class="code" href="a00174.html">concurrent_hash_map</a>(<span class="keyword">const</span> allocator_type &amp;a = allocator_type())
00410         : my_allocator(a)
00411 
00412     {
00413         initialize();
00414     }
00415 
<a name="l00417"></a><a class="code" href="a00174.html#a1">00417</a>     <a class="code" href="a00174.html">concurrent_hash_map</a>( <span class="keyword">const</span> <a class="code" href="a00174.html">concurrent_hash_map</a>&amp; table, <span class="keyword">const</span> allocator_type &amp;a = allocator_type())
00418         : my_allocator(a)
00419     {
00420         initialize();
00421         internal_copy(table);
00422     }
00423 
00425     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> I&gt;
<a name="l00426"></a><a class="code" href="a00174.html#a2">00426</a>     <a class="code" href="a00174.html">concurrent_hash_map</a>(I first, I last, <span class="keyword">const</span> allocator_type &amp;a = allocator_type())
00427         : my_allocator(a)
00428     {
00429         initialize();
00430         internal_copy(first, last);
00431     }
00432 
<a name="l00434"></a><a class="code" href="a00174.html#a3">00434</a>     <a class="code" href="a00174.html">concurrent_hash_map</a>&amp; operator=( <span class="keyword">const</span> <a class="code" href="a00174.html">concurrent_hash_map</a>&amp; table ) {
00435         <span class="keywordflow">if</span>( <span class="keyword">this</span>!=&amp;table ) {
00436             clear();
00437             internal_copy(table);
00438         } 
00439         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00440     }
00441 
00442 
00444     <span class="keywordtype">void</span> clear();
00445 
00447     ~<a class="code" href="a00174.html">concurrent_hash_map</a>();
00448 
00449     <span class="comment">//------------------------------------------------------------------------</span>
00450     <span class="comment">// Parallel algorithm support</span>
00451     <span class="comment">//------------------------------------------------------------------------</span>
00452     range_type range( size_type grainsize=1 ) {
00453         <span class="keywordflow">return</span> range_type( begin(), end(), grainsize );
00454     }
00455     const_range_type range( size_type grainsize=1 )<span class="keyword"> const </span>{
00456         <span class="keywordflow">return</span> const_range_type( begin(), end(), grainsize );
00457     }
00458 
00459     <span class="comment">//------------------------------------------------------------------------</span>
00460     <span class="comment">// STL support - not thread-safe methods</span>
00461     <span class="comment">//------------------------------------------------------------------------</span>
00462     iterator begin() {<span class="keywordflow">return</span> iterator(*<span class="keyword">this</span>,0);}
00463     iterator end() {<span class="keywordflow">return</span> iterator(*<span class="keyword">this</span>,n_segment);}
00464     const_iterator begin()<span class="keyword"> const </span>{<span class="keywordflow">return</span> const_iterator(*<span class="keyword">this</span>,0);}
00465     const_iterator end()<span class="keyword"> const </span>{<span class="keywordflow">return</span> const_iterator(*<span class="keyword">this</span>,n_segment);}
00466     std::pair&lt;iterator, iterator&gt; equal_range( <span class="keyword">const</span> Key&amp; key ) { <span class="keywordflow">return</span> internal_equal_range(key, end()); }
00467     std::pair&lt;const_iterator, const_iterator&gt; equal_range( <span class="keyword">const</span> Key&amp; key )<span class="keyword"> const </span>{ <span class="keywordflow">return</span> internal_equal_range(key, end()); }
00468     
00470 
00472     size_type size() <span class="keyword">const</span>;
00473 
00475     <span class="keywordtype">bool</span> empty() <span class="keyword">const</span>;
00476 
<a name="l00478"></a><a class="code" href="a00174.html#a16">00478</a>     size_type max_size()<span class="keyword"> const </span>{<span class="keywordflow">return</span> (~size_type(0))/<span class="keyword">sizeof</span>(node);}
00479 
<a name="l00481"></a><a class="code" href="a00174.html#a17">00481</a>     allocator_type get_allocator()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> this-&gt;my_allocator; }
00482 
00484     <span class="keywordtype">void</span> swap(<a class="code" href="a00174.html">concurrent_hash_map</a> &amp;table);
00485 
00486     <span class="comment">//------------------------------------------------------------------------</span>
00487     <span class="comment">// concurrent map operations</span>
00488     <span class="comment">//------------------------------------------------------------------------</span>
00489 
<a name="l00491"></a><a class="code" href="a00174.html#a19">00491</a>     size_type count( <span class="keyword">const</span> Key&amp; key )<span class="keyword"> const </span>{
00492         <span class="keywordflow">return</span> const_cast&lt;concurrent_hash_map*&gt;(<span class="keyword">this</span>)-&gt;lookup&lt;<span class="comment">/*insert*/</span><span class="keyword">false</span>&gt;(NULL, key, <span class="comment">/*write=*/</span><span class="keyword">false</span>, NULL );
00493     }
00494 
00496 
<a name="l00497"></a><a class="code" href="a00174.html#a20">00497</a>     <span class="keywordtype">bool</span> find( <a class="code" href="a00176.html">const_accessor</a>&amp; result, <span class="keyword">const</span> Key&amp; key )<span class="keyword"> const </span>{
00498         <span class="keywordflow">return</span> const_cast&lt;concurrent_hash_map*&gt;(<span class="keyword">this</span>)-&gt;lookup&lt;<span class="comment">/*insert*/</span><span class="keyword">false</span>&gt;(&amp;result, key, <span class="comment">/*write=*/</span><span class="keyword">false</span>, NULL );
00499     }
00500 
00502 
<a name="l00503"></a><a class="code" href="a00174.html#a21">00503</a>     <span class="keywordtype">bool</span> find( <a class="code" href="a00175.html">accessor</a>&amp; result, <span class="keyword">const</span> Key&amp; key ) {
00504         <span class="keywordflow">return</span> lookup&lt;<span class="comment">/*insert*/</span><span class="keyword">false</span>&gt;(&amp;result, key, <span class="comment">/*write=*/</span><span class="keyword">true</span>, NULL );
00505     }
00506         
00508 
<a name="l00509"></a><a class="code" href="a00174.html#a22">00509</a>     <span class="keywordtype">bool</span> insert( <a class="code" href="a00176.html">const_accessor</a>&amp; result, <span class="keyword">const</span> Key&amp; key ) {
00510         <span class="keywordflow">return</span> lookup&lt;<span class="comment">/*insert*/</span><span class="keyword">true</span>&gt;(&amp;result, key, <span class="comment">/*write=*/</span><span class="keyword">false</span>, NULL );
00511     }
00512 
00514 
<a name="l00515"></a><a class="code" href="a00174.html#a23">00515</a>     <span class="keywordtype">bool</span> insert( <a class="code" href="a00175.html">accessor</a>&amp; result, <span class="keyword">const</span> Key&amp; key ) {
00516         <span class="keywordflow">return</span> lookup&lt;<span class="comment">/*insert*/</span><span class="keyword">true</span>&gt;(&amp;result, key, <span class="comment">/*write=*/</span><span class="keyword">true</span>, NULL );
00517     }
00518 
00520 
<a name="l00521"></a><a class="code" href="a00174.html#a24">00521</a>     <span class="keywordtype">bool</span> insert( <a class="code" href="a00176.html">const_accessor</a>&amp; result, <span class="keyword">const</span> value_type&amp; value ) {
00522         <span class="keywordflow">return</span> lookup&lt;<span class="comment">/*insert*/</span><span class="keyword">true</span>&gt;(&amp;result, value.first, <span class="comment">/*write=*/</span><span class="keyword">false</span>, &amp;value.second );
00523     }
00524 
00526 
<a name="l00527"></a><a class="code" href="a00174.html#a25">00527</a>     <span class="keywordtype">bool</span> insert( <a class="code" href="a00175.html">accessor</a>&amp; result, <span class="keyword">const</span> value_type&amp; value ) {
00528         <span class="keywordflow">return</span> lookup&lt;<span class="comment">/*insert*/</span><span class="keyword">true</span>&gt;(&amp;result, value.first, <span class="comment">/*write=*/</span><span class="keyword">true</span>, &amp;value.second );
00529     }
00530 
00532 
<a name="l00533"></a><a class="code" href="a00174.html#a26">00533</a>     <span class="keywordtype">bool</span> insert( <span class="keyword">const</span> value_type&amp; value ) {
00534         <span class="keywordflow">return</span> lookup&lt;<span class="comment">/*insert*/</span><span class="keyword">true</span>&gt;(NULL, value.first, <span class="comment">/*write=*/</span><span class="keyword">false</span>, &amp;value.second );
00535     }
00536 
00538     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> I&gt;
<a name="l00539"></a><a class="code" href="a00174.html#a27">00539</a>     <span class="keywordtype">void</span> insert(I first, I last) {
00540         <span class="keywordflow">for</span>(; first != last; ++first)
00541             insert( *first );
00542     }
00543 
00545 
00546     <span class="keywordtype">bool</span> erase( <span class="keyword">const</span> Key&amp; key );
00547 
00549 
<a name="l00550"></a><a class="code" href="a00174.html#a29">00550</a>     <span class="keywordtype">bool</span> erase( <a class="code" href="a00176.html">const_accessor</a>&amp; item_accessor ) {
00551         <span class="keywordflow">return</span> exclude( item_accessor, <span class="comment">/*readonly=*/</span> <span class="keyword">true</span> );
00552     }
00553 
00555 
<a name="l00556"></a><a class="code" href="a00174.html#a30">00556</a>     <span class="keywordtype">bool</span> erase( <a class="code" href="a00175.html">accessor</a>&amp; item_accessor ) {
00557         <span class="keywordflow">return</span> exclude( item_accessor, <span class="comment">/*readonly=*/</span> <span class="keyword">false</span> );
00558     }
00559 
00560 <span class="keyword">private</span>:
00562     <span class="keyword">struct </span>node {
00564         node* next;
00565         node_mutex_t <a class="code" href="a00198.html">mutex</a>;
00566         value_type item;
00567         node( <span class="keyword">const</span> Key&amp; key ) : item(key, T()) {}
00568         node( <span class="keyword">const</span> Key&amp; key, <span class="keyword">const</span> T&amp; t ) : item(key, t) {}
00569         <span class="comment">// exception-safe allocation, see C++ Standard 2003, clause 5.3.4p17</span>
00570         <span class="keywordtype">void</span>* operator new( size_t size, node_allocator_type&amp; a ) {
00571             <span class="keywordtype">void</span> *ptr = a.allocate(1);
00572             <span class="keywordflow">if</span>(!ptr) <span class="keywordflow">throw</span> std::bad_alloc();
00573             <span class="keywordflow">return</span> ptr;
00574         }
00575         <span class="comment">// match placement-new form above to be called if exception thrown in constructor</span>
00576         <span class="keywordtype">void</span> operator delete( <span class="keywordtype">void</span>* ptr, node_allocator_type&amp; a ) {<span class="keywordflow">return</span> a.deallocate(static_cast&lt;node*&gt;(ptr),1); }
00577     };
00578 
00579     <span class="keyword">struct </span>chain;
00580     <span class="keyword">friend</span> <span class="keyword">struct </span>chain;
00581 
00583 
00584     <span class="keyword">struct </span>chain {
00585         <span class="keywordtype">void</span> push_front( node&amp; b ) {
00586             b.next = node_list;
00587             node_list = &amp;b;
00588         }
00589         chain_mutex_t mutex;
00590         node* node_list;
00591     };
00592 
00593     <span class="keyword">struct </span>segment;
00594     <span class="keyword">friend</span> <span class="keyword">struct </span>segment;
00595 
00597 
00599     <span class="keyword">struct </span>segment: internal::hash_map_segment_base {
00600 <span class="preprocessor">#if TBB_DO_ASSERT</span>
00601 <span class="preprocessor"></span>        ~segment() {
00602             __TBB_ASSERT( !my_array, <span class="stringliteral">"should have been cleared earlier"</span> );
00603         }
00604 <span class="preprocessor">#endif </span><span class="comment">/* TBB_DO_ASSERT */</span>
00605 
00606         <span class="comment">// Pointer to array of chains</span>
00607         chain* my_array;
00608 
00609         <span class="comment">// Get chain in this segment that corresponds to given hash code.</span>
00610         chain&amp; get_chain( hashcode_t hashcode, size_t n_segment_bits ) {
00611             <span class="keywordflow">return</span> my_array[(hashcode&gt;&gt;n_segment_bits)&amp;(my_physical_size-1)];
00612         }
00613      
00615 
00617         <span class="keywordtype">void</span> allocate_array( size_t new_size ) {
00618             size_t n=(internal::NFS_GetLineSize()+<span class="keyword">sizeof</span>(chain)-1)/<span class="keyword">sizeof</span>(chain);
00619             __TBB_ASSERT((n&amp;(n-1))==0, NULL);
00620             <span class="keywordflow">while</span>( n&lt;new_size ) n&lt;&lt;=1;
00621             chain* array = cache_aligned_allocator&lt;chain&gt;().allocate( n );
00622             <span class="comment">// storing earlier might help overcome false positives of in deducing "bool grow" in concurrent threads</span>
00623             __TBB_store_with_release(my_physical_size, n);
00624             memset( array, 0, n*<span class="keyword">sizeof</span>(chain) );
00625             my_array = array;
00626         }
00627     };
00628 
00629     segment&amp; get_segment( hashcode_t hashcode ) {
00630         <span class="keywordflow">return</span> my_segment[hashcode&amp;(n_segment-1)];
00631     }
00632 
00633     node_allocator_type my_allocator;
00634 
00635     HashCompare my_hash_compare;
00636 
00637     segment* my_segment;
00638 
00639     node* create_node(<span class="keyword">const</span> Key&amp; key, <span class="keyword">const</span> T* t) {
00640         <span class="comment">// exception-safe allocation and construction</span>
00641         <span class="keywordflow">if</span>(t) <span class="keywordflow">return</span> <span class="keyword">new</span>( my_allocator ) node(key, *t);
00642         <span class="keywordflow">else</span>  <span class="keywordflow">return</span> <span class="keyword">new</span>( my_allocator ) node(key);
00643     }
00644 
00645     <span class="keywordtype">void</span> delete_node(node* b) {
00646         my_allocator.destroy(b);
00647         my_allocator.deallocate(b, 1);
00648     }
00649 
00650     node* search_list( <span class="keyword">const</span> Key&amp; key, chain&amp; c )<span class="keyword"> const </span>{
00651         node* b = c.node_list;
00652         <span class="keywordflow">while</span>( b &amp;&amp; !my_hash_compare.equal(key, b-&gt;item.first) )
00653             b = b-&gt;next;
00654         <span class="keywordflow">return</span> b;
00655     }
00657     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> I&gt;
00658     std::pair&lt;I, I&gt; internal_equal_range( <span class="keyword">const</span> Key&amp; key, I end ) <span class="keyword">const</span>;
00659 
00661     <span class="keywordtype">bool</span> exclude( const_accessor&amp; item_accessor, <span class="keywordtype">bool</span> readonly );
00662 
00664     <span class="keywordtype">void</span> grow_segment( segment_mutex_t::scoped_lock&amp; segment_lock, segment&amp; s );
00665 
00667     <span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> op_insert&gt;
00668     <span class="keywordtype">bool</span> lookup( const_accessor* result, <span class="keyword">const</span> Key&amp; key, <span class="keywordtype">bool</span> write, <span class="keyword">const</span> T* t );
00669 
00671     <span class="keywordtype">void</span> initialize() {
00672         my_segment = cache_aligned_allocator&lt;segment&gt;().allocate(n_segment);
00673         memset( my_segment, 0, <span class="keyword">sizeof</span>(segment)*n_segment );
00674      }
00675 
00677     <span class="keywordtype">void</span> internal_copy( <span class="keyword">const</span> concurrent_hash_map&amp; source );
00678 
00679     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> I&gt;
00680     <span class="keywordtype">void</span> internal_copy(I first, I last);
00681 };
00682 
00683 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare, <span class="keyword">typename</span> A&gt;
<a name="l00684"></a><a class="code" href="a00174.html#a5">00684</a> <a class="code" href="a00174.html">concurrent_hash_map&lt;Key,T,HashCompare,A&gt;::~concurrent_hash_map</a>() {
00685     <a class="code" href="a00174.html#a4">clear</a>();
00686     <a class="code" href="a00172.html">cache_aligned_allocator&lt;segment&gt;</a>().deallocate( my_segment, n_segment );
00687 }
00688 
00689 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare, <span class="keyword">typename</span> A&gt;
<a name="l00690"></a><a class="code" href="a00174.html#a14">00690</a> <span class="keyword">typename</span> <a class="code" href="a00174.html">concurrent_hash_map&lt;Key,T,HashCompare,A&gt;</a>::size_type <a class="code" href="a00174.html">concurrent_hash_map&lt;Key,T,HashCompare,A&gt;::size</a>()<span class="keyword"> const </span>{
00691     size_type result = 0;
00692     <span class="keywordflow">for</span>( size_t k=0; k&lt;n_segment; ++k )
00693         result += my_segment[k].my_logical_size;
00694     <span class="keywordflow">return</span> result;
00695 }
00696 
00697 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare, <span class="keyword">typename</span> A&gt;
<a name="l00698"></a><a class="code" href="a00174.html#a15">00698</a> <span class="keywordtype">bool</span> <a class="code" href="a00174.html">concurrent_hash_map&lt;Key,T,HashCompare,A&gt;::empty</a>()<span class="keyword"> const </span>{
00699     <span class="keywordflow">for</span>( size_t k=0; k&lt;n_segment; ++k )
00700         <span class="keywordflow">if</span>( my_segment[k].my_logical_size )
00701             <span class="keywordflow">return</span> <span class="keyword">false</span>;
00702     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00703 }
00704 
00705 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare, <span class="keyword">typename</span> A&gt;
00706 <span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> op_insert&gt;
00707 <span class="keywordtype">bool</span> <a class="code" href="a00174.html">concurrent_hash_map&lt;Key,T,HashCompare,A&gt;::lookup</a>( const_accessor* result, <span class="keyword">const</span> Key&amp; key, <span class="keywordtype">bool</span> write, <span class="keyword">const</span> T* t ) {
00708     <span class="keywordflow">if</span>( result <span class="comment">/*&amp;&amp; result-&gt;my_node -- checked in release() */</span> )
00709         result-&gt;release();
00710     <span class="keyword">const</span> hashcode_t h = my_hash_compare.hash( key );
00711     segment&amp; s = get_segment(h);
00712 restart:
00713     <span class="keywordtype">bool</span> return_value = <span class="keyword">false</span>;
00714     <span class="comment">// first check in double-check sequence</span>
00715 <span class="preprocessor">#if TBB_DO_THREADING_TOOLS||TBB_DO_ASSERT</span>
00716 <span class="preprocessor"></span>    <span class="keyword">const</span> <span class="keywordtype">bool</span> grow = op_insert &amp;&amp; s.internal_grow_predicate();
00717 <span class="preprocessor">#else</span>
00718 <span class="preprocessor"></span>    <span class="keyword">const</span> <span class="keywordtype">bool</span> grow = op_insert &amp;&amp; s.my_logical_size &gt;= s.my_physical_size
00719         &amp;&amp; s.my_physical_size &lt; max_physical_size; <span class="comment">// check whether there are free bits</span>
00720 <span class="preprocessor">#endif </span><span class="comment">/* TBB_DO_THREADING_TOOLS||TBB_DO_ASSERT */</span>
00721     segment_mutex_t::scoped_lock segment_lock( s.my_mutex, <span class="comment">/*write=*/</span>grow );
00722     <span class="keywordflow">if</span>( grow ) { <span class="comment">// Load factor is too high  </span>
00723         grow_segment( segment_lock, s );
00724     }
00725     <span class="keywordflow">if</span>( !s.my_array ) {
00726         __TBB_ASSERT( !op_insert, NULL );
00727         <span class="keywordflow">return</span> <span class="keyword">false</span>;
00728     }
00729     __TBB_ASSERT( (s.my_physical_size&amp;(s.my_physical_size-1))==0, NULL );
00730     chain&amp; c = s.get_chain( h, n_segment_bits );
00731     chain_mutex_t::scoped_lock chain_lock( c.mutex, <span class="comment">/*write=*/</span><span class="keyword">false</span> );
00732 
00733     node* b = search_list( key, c );
00734     <span class="keywordflow">if</span>( op_insert ) {
00735         <span class="keywordflow">if</span>( !b ) {
00736             b = create_node(key, t);
00737             <span class="comment">// Search failed</span>
00738             <span class="keywordflow">if</span>( !chain_lock.upgrade_to_writer() ) {
00739                 <span class="comment">// Rerun search_list, in case another thread inserted the item during the upgrade.</span>
00740                 node* b_temp = search_list( key, c );
00741                 <span class="keywordflow">if</span>( b_temp ) { <span class="comment">// unfortunately, it did</span>
00742                     chain_lock.downgrade_to_reader();
00743                     delete_node( b );
00744                     b = b_temp;
00745                     <span class="keywordflow">goto</span> done;
00746                 }
00747             }
00748             ++s.my_logical_size; <span class="comment">// we can't change it earlier due to correctness of size() and exception safety of equal()</span>
00749             return_value = <span class="keyword">true</span>;
00750             c.push_front( *b );
00751         }
00752     } <span class="keywordflow">else</span> { <span class="comment">// find or count</span>
00753         <span class="keywordflow">if</span>( !b )      <span class="keywordflow">return</span> <span class="keyword">false</span>;
00754         return_value = <span class="keyword">true</span>;
00755     }
00756 done:
00757     <span class="keywordflow">if</span>( !result ) <span class="keywordflow">return</span> return_value;
00758     <span class="keywordflow">if</span>( !result-&gt;my_lock.try_acquire( b-&gt;mutex, write ) ) {
00759         <span class="comment">// we are unlucky, prepare for longer wait</span>
00760         internal::AtomicBackoff trials;
00761         <span class="keywordflow">do</span> {
00762             <span class="keywordflow">if</span>( !trials.bounded_pause() ) {
00763                 <span class="comment">// the wait takes really long, restart the operation</span>
00764                 chain_lock.release(); segment_lock.release();
00765                 __TBB_Yield();
00766                 <span class="keywordflow">goto</span> restart;
00767             }
00768         } <span class="keywordflow">while</span>( !result-&gt;my_lock.try_acquire( b-&gt;mutex, write ) );
00769     }
00770     result-&gt;my_node = b;
00771     result-&gt;my_hash = h;
00772     <span class="keywordflow">return</span> return_value;
00773 }
00774 
00775 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare, <span class="keyword">typename</span> A&gt;
00776 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> I&gt;
00777 std::pair&lt;I, I&gt; concurrent_hash_map&lt;Key,T,HashCompare,A&gt;::internal_equal_range( <span class="keyword">const</span> Key&amp; key, I end )<span class="keyword"> const </span>{
00778     <a class="code" href="a00195.html#w3">hashcode_t</a> h = my_hash_compare.hash( key );
00779     size_t segment_index = h&amp;(<a class="code" href="a00195.html#s1">n_segment</a>-1);
00780     segment&amp; s = my_segment[segment_index ];
00781     size_t chain_index = (h&gt;&gt;n_segment_bits)&amp;(s.my_physical_size-1);
00782     <span class="keywordflow">if</span>( !s.my_array )
00783         <span class="keywordflow">return</span> std::make_pair(end, end);
00784     chain&amp; c = s.my_array[chain_index];
00785     node* b = search_list( key, c );
00786     <span class="keywordflow">if</span>( !b )
00787         <span class="keywordflow">return</span> std::make_pair(end, end);
00788     iterator lower(*<span class="keyword">this</span>, segment_index, chain_index, b), upper(lower);
00789     <span class="keywordflow">return</span> std::make_pair(lower, ++upper);
00790 }
00791 
00792 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare, <span class="keyword">typename</span> A&gt;
<a name="l00793"></a><a class="code" href="a00174.html#a28">00793</a> <span class="keywordtype">bool</span> <a class="code" href="a00174.html">concurrent_hash_map&lt;Key,T,HashCompare,A&gt;::erase</a>( <span class="keyword">const</span> Key &amp;key ) {
00794     hashcode_t h = my_hash_compare.hash( key );
00795     segment&amp; s = get_segment( h );
00796     node* b;
00797     {
00798         <span class="keywordtype">bool</span> chain_locked_for_write = <span class="keyword">false</span>;
00799         segment_mutex_t::scoped_lock segment_lock( s.my_mutex, <span class="comment">/*write=*/</span><span class="keyword">false</span> );
00800         <span class="keywordflow">if</span>( !s.my_array ) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00801         __TBB_ASSERT( (s.my_physical_size&amp;(s.my_physical_size-1))==0, NULL );
00802         chain&amp; c = s.get_chain( h, n_segment_bits );
00803         chain_mutex_t::scoped_lock chain_lock( c.mutex, <span class="comment">/*write=*/</span><span class="keyword">false</span> );
00804     search:
00805         node** p = &amp;c.node_list;
00806         b = *p;
00807         <span class="keywordflow">while</span>( b &amp;&amp; !my_hash_compare.equal(key, b-&gt;item.first ) ) {
00808             p = &amp;b-&gt;next;
00809             b = *p;
00810         }
00811         <span class="keywordflow">if</span>( !b ) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00812         <span class="keywordflow">if</span>( !chain_locked_for_write &amp;&amp; !chain_lock.upgrade_to_writer() ) {
00813             chain_locked_for_write = <span class="keyword">true</span>;
00814             <span class="keywordflow">goto</span> search;
00815         }
00816         *p = b-&gt;next;
00817         --s.my_logical_size;
00818     }
00819     {
00820         node_mutex_t::scoped_lock item_locker( b-&gt;mutex, <span class="comment">/*write=*/</span><span class="keyword">true</span> );
00821     }
00822     <span class="comment">// note: there should be no threads pretending to acquire this mutex again, do not try to upgrade const_accessor!</span>
00823     delete_node( b ); <span class="comment">// Only one thread can delete it due to write lock on the chain_mutex</span>
00824     <span class="keywordflow">return</span> <span class="keyword">true</span>;        
00825 }
00826 
00827 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare, <span class="keyword">typename</span> A&gt;
00828 <span class="keywordtype">bool</span> <a class="code" href="a00174.html">concurrent_hash_map&lt;Key,T,HashCompare,A&gt;::exclude</a>( const_accessor &amp;item_accessor, <span class="keywordtype">bool</span> readonly ) {
00829     __TBB_ASSERT( item_accessor.my_node, NULL );
00830     <span class="keyword">const</span> hashcode_t h = item_accessor.my_hash;
00831     node *<span class="keyword">const</span> b = item_accessor.my_node;
00832     item_accessor.my_node = NULL; <span class="comment">// we ought release accessor anyway</span>
00833     segment&amp; s = get_segment( h );
00834     {
00835         segment_mutex_t::scoped_lock segment_lock( s.my_mutex, <span class="comment">/*write=*/</span><span class="keyword">false</span> );
00836         __TBB_ASSERT( s.my_array, NULL );
00837         __TBB_ASSERT( (s.my_physical_size&amp;(s.my_physical_size-1))==0, NULL );
00838         chain&amp; c = s.get_chain( h, n_segment_bits );
00839         chain_mutex_t::scoped_lock chain_lock( c.mutex, <span class="comment">/*write=*/</span><span class="keyword">true</span> );
00840         node** p = &amp;c.node_list;
00841         <span class="keywordflow">while</span>( *p &amp;&amp; *p != b )
00842             p = &amp;(*p)-&gt;next;
00843         <span class="keywordflow">if</span>( !*p ) { <span class="comment">// someone else was the first</span>
00844             item_accessor.my_lock.release();
00845             <span class="keywordflow">return</span> <span class="keyword">false</span>;
00846         }
00847         __TBB_ASSERT( *p == b, NULL );
00848         *p = b-&gt;next;
00849         --s.my_logical_size;
00850     }
00851     <span class="keywordflow">if</span>( readonly ) <span class="comment">// need to get exclusive lock</span>
00852         item_accessor.my_lock.upgrade_to_writer(); <span class="comment">// return value means nothing here</span>
00853     item_accessor.my_lock.release();
00854     delete_node( b ); <span class="comment">// Only one thread can delete it due to write lock on the chain_mutex</span>
00855     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00856 }
00857 
00858 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare, <span class="keyword">typename</span> A&gt;
<a name="l00859"></a><a class="code" href="a00174.html#a18">00859</a> <span class="keywordtype">void</span> <a class="code" href="a00174.html">concurrent_hash_map&lt;Key,T,HashCompare,A&gt;::swap</a>(<a class="code" href="a00174.html">concurrent_hash_map&lt;Key,T,HashCompare,A&gt;</a> &amp;table) {
00860     std::swap(this-&gt;my_allocator, table.<a class="code" href="a00174.html#r0">my_allocator</a>);
00861     std::swap(this-&gt;my_hash_compare, table.<a class="code" href="a00174.html#r1">my_hash_compare</a>);
00862     std::swap(this-&gt;my_segment, table.<a class="code" href="a00174.html#r2">my_segment</a>);
00863 }
00864 
00865 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare, <span class="keyword">typename</span> A&gt;
<a name="l00866"></a><a class="code" href="a00174.html#a4">00866</a> <span class="keywordtype">void</span> <a class="code" href="a00174.html">concurrent_hash_map&lt;Key,T,HashCompare,A&gt;::clear</a>() {
00867 <span class="preprocessor">#if TBB_PERFORMANCE_WARNINGS</span>
00868 <span class="preprocessor"></span>    size_t total_physical_size = 0, min_physical_size = size_t(-1L), max_physical_size = 0; <span class="comment">//&lt; usage statistics</span>
00869     <span class="keyword">static</span> <span class="keywordtype">bool</span> reported = <span class="keyword">false</span>;
00870 <span class="preprocessor">#endif</span>
00871 <span class="preprocessor"></span>    <span class="keywordflow">for</span>( size_t i=0; i&lt;n_segment; ++i ) {
00872         segment&amp; s = my_segment[i];
00873         size_t n = s.my_physical_size;
00874         <span class="keywordflow">if</span>( chain* array = s.my_array ) {
00875             s.my_array = NULL;
00876             s.my_physical_size = 0;
00877             s.my_logical_size = 0;
00878             <span class="keywordflow">for</span>( size_t j=0; j&lt;n; ++j ) {
00879                 <span class="keywordflow">while</span>( node* b = array[j].node_list ) {
00880                     array[j].node_list = b-&gt;next;
00881                     delete_node(b);
00882                 }
00883             }
00884             <a class="code" href="a00172.html">cache_aligned_allocator&lt;chain&gt;</a>().deallocate( array, n );
00885         }
00886 <span class="preprocessor">#if TBB_PERFORMANCE_WARNINGS</span>
00887 <span class="preprocessor"></span>        total_physical_size += n;
00888         <span class="keywordflow">if</span>(min_physical_size &gt; n) min_physical_size = n;
00889         <span class="keywordflow">if</span>(max_physical_size &lt; n) max_physical_size = n;
00890     }
00891     <span class="keywordflow">if</span>( !reported
00892         &amp;&amp; ( (total_physical_size &gt;= n_segment*48 &amp;&amp; min_physical_size &lt; total_physical_size/n_segment/2)
00893          || (total_physical_size &gt;= n_segment*128 &amp;&amp; max_physical_size &gt; total_physical_size/n_segment*2) ) )
00894     {
00895         reported = <span class="keyword">true</span>;
00896         internal::runtime_warning(
00897             <span class="stringliteral">"Performance is not optimal because the hash function produces bad randomness in lower bits in %s"</span>,
00898             <span class="keyword">typeid</span>(*this).name() );
00899 <span class="preprocessor">#endif</span>
00900 <span class="preprocessor"></span>    }
00901 }
00902 
00903 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare, <span class="keyword">typename</span> A&gt;
00904 <span class="keywordtype">void</span> <a class="code" href="a00174.html">concurrent_hash_map&lt;Key,T,HashCompare,A&gt;::grow_segment</a>( segment_mutex_t::scoped_lock&amp; segment_lock, segment&amp; s ) {
00905     <span class="comment">// Following is second check in a double-check.</span>
00906     <span class="keywordflow">if</span>( s.my_logical_size &gt;= s.my_physical_size ) {
00907         chain* old_array = s.my_array;
00908         size_t old_size = s.my_physical_size;
00909         s.allocate_array( s.my_logical_size+1 );
00910         <span class="keywordflow">for</span>( size_t k=0; k&lt;old_size; ++k )
00911             <span class="keywordflow">while</span>( node* b = old_array[k].node_list ) {
00912                 old_array[k].node_list = b-&gt;next;
00913                 hashcode_t h = my_hash_compare.hash( b-&gt;item.first );
00914                 __TBB_ASSERT( &amp;get_segment(h)==&amp;s, <span class="stringliteral">"hash function changed?"</span> );
00915                 s.get_chain(h,n_segment_bits).push_front(*b);
00916             }
00917         cache_aligned_allocator&lt;chain&gt;().deallocate( old_array, old_size );
00918     }
00919     segment_lock.downgrade_to_reader();
00920 }
00921 
00922 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare, <span class="keyword">typename</span> A&gt;
00923 <span class="keywordtype">void</span> concurrent_hash_map&lt;Key,T,HashCompare,A&gt;::internal_copy( <span class="keyword">const</span> concurrent_hash_map&amp; source ) {
00924     <span class="keywordflow">for</span>( size_t i=0; i&lt;n_segment; ++i ) {
00925         segment&amp; s = source.my_segment[i];
00926         __TBB_ASSERT( !my_segment[i].my_array, <span class="stringliteral">"caller should have cleared"</span> );
00927         <span class="keywordflow">if</span>( s.my_logical_size ) {
00928             segment&amp; d = my_segment[i];
00929             d.allocate_array( s.my_logical_size );
00930             d.my_logical_size = s.my_logical_size;
00931             size_t s_size = s.my_physical_size;
00932             chain* s_array = s.my_array;
00933             chain* d_array = d.my_array;
00934             <span class="keywordflow">for</span>( size_t k=0; k&lt;s_size; ++k )
00935                 <span class="keywordflow">for</span>( node* b = s_array[k].node_list; b; b=b-&gt;next ) {
00936                     __TBB_ASSERT( &amp;get_segment(my_hash_compare.hash( b-&gt;item.first ))==&amp;d, <span class="stringliteral">"hash function changed?"</span> );
00937                     node* b_new = create_node(b-&gt;item.first, &amp;b-&gt;item.second);
00938                     d_array[k].push_front(*b_new); <span class="comment">// hashcode is the same and segment and my_physical sizes are the same</span>
00939                 }
00940         }
00941     }
00942 }
00943 
00944 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare, <span class="keyword">typename</span> A&gt;
00945 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> I&gt;
00946 <span class="keywordtype">void</span> concurrent_hash_map&lt;Key,T,HashCompare,A&gt;::internal_copy(I first, I last) {
00947     <span class="keywordflow">for</span>(; first != last; ++first)
00948         <a class="code" href="a00174.html#a22">insert</a>( *first );
00949 }
00950 
00951 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare, <span class="keyword">typename</span> A1, <span class="keyword">typename</span> A2&gt;
00952 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> concurrent_hash_map&lt;Key, T, HashCompare, A1&gt; &amp;a, <span class="keyword">const</span> concurrent_hash_map&lt;Key, T, HashCompare, A2&gt; &amp;b) {
00953     <span class="keywordflow">if</span>(a.size() != b.size()) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00954     <span class="keyword">typename</span> concurrent_hash_map&lt;Key, T, HashCompare, A1&gt;::const_iterator i(a.begin()), i_end(a.end());
00955     <span class="keyword">typename</span> concurrent_hash_map&lt;Key, T, HashCompare, A2&gt;::const_iterator j, j_end(b.end());
00956     <span class="keywordflow">for</span>(; i != i_end; ++i) {
00957         j = b.equal_range(i-&gt;first).first;
00958         <span class="keywordflow">if</span>( j == j_end || !(i-&gt;second == j-&gt;second) ) <span class="keywordflow">return</span> <span class="keyword">false</span>;
00959     }
00960     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00961 }
00962 
00963 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare, <span class="keyword">typename</span> A1, <span class="keyword">typename</span> A2&gt;
00964 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator!=(<span class="keyword">const</span> concurrent_hash_map&lt;Key, T, HashCompare, A1&gt; &amp;a, <span class="keyword">const</span> concurrent_hash_map&lt;Key, T, HashCompare, A2&gt; &amp;b)
00965 {    <span class="keywordflow">return</span> !(a == b); }
00966 
00967 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> T, <span class="keyword">typename</span> HashCompare, <span class="keyword">typename</span> A&gt;
00968 <span class="keyword">inline</span> <span class="keywordtype">void</span> swap(concurrent_hash_map&lt;Key, T, HashCompare, A&gt; &amp;a, concurrent_hash_map&lt;Key, T, HashCompare, A&gt; &amp;b)
00969 {    a.swap( b ); }
00970 
00971 } <span class="comment">// namespace tbb</span>
00972 
00973 <span class="preprocessor">#endif </span><span class="comment">/* __TBB_concurrent_hash_map_H */</span>
</pre></div><hr>
<p></p>
Copyright &copy; 2005-2008 Intel Corporation.  All Rights Reserved.
<p></p>
Intel, Pentium, Intel Xeon, Itanium, Intel XScale and VTune are
registered trademarks or trademarks of Intel Corporation or its
subsidiaries in the United States and other countries.
<p></p>
* Other names and brands may be claimed as the property of others.
