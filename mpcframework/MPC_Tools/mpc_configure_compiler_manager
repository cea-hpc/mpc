#!/bin/sh
############################# MPC License ############################## 
# Wed Nov 19 15:19:19 CET 2008                                         # 
# Copyright or (C) or Copr. Commissariat a l'Energie Atomique          # 
#                                                                      # 
# IDDN.FR.001.230040.000.S.P.2007.000.10000                            # 
# This file is part of the MPC Runtime.                                # 
#                                                                      # 
# This software is governed by the CeCILL-C license under French law   # 
# and abiding by the rules of distribution of free software.  You can  # 
# use, modify and/ or redistribute the software under the terms of     # 
# the CeCILL-C license as circulated by CEA, CNRS and INRIA at the     # 
# following URL http://www.cecill.info.                                # 
#                                                                      # 
# The fact that you are presently reading this means that you have     # 
# had knowledge of the CeCILL-C license and that you accept its        # 
# terms.                                                               # 
#                                                                      # 
# Authors:                                                             # 
#   - PERACHE Marc marc.perache@cea.fr                                 # 
#   - CARRIBAULT Patrick patrick.carribault@cea.fr                     # 
#                                                                      # 
######################################################################## 

cat <<EOF > bin/mpc_compiler_manager
#!/bin/sh

#trailing spaces are needed for matching w/ 'egrep'
list_languages=" c cxx fortran "
CHECKSUM_TOOL=sha1sum
CREATION_TIMESTAMP="`date -u +"%s"`"

# Some clarifications:
# This script needs root prefix directory AND host/target specifialization (Fortran compilation)
# To get these two paths, 2 scenarios can occur:
# 1. MPC is installed and the user sourced mpcvars.sh, both these values can be found in the environment
# 2. Any other situation, this script can still be called (should not by the user), for example by installmpc/Makefile during installation process. For this second case, we have to test for MPC_SUBPREFIX
if test -n "\${MPC_RPREFIX}" -a -n "\${MPC_SUBPREFIX}"; then
	MPC_prefix=\$MPC_RPREFIX/\$MPC_SUBPREFIX/
else
	#attempt to guess MPC prefix = current script looks like PREFIX/host/target/bin/manager
	MPC_prefix=\`dirname \$0\`/../
	MPC_RPREFIX="\`readlink -e \$MPC_prefix/../../\`"
fi

die()
{
	printf "\${RED}Error: \$@\n\${DEF}" 1>&2
	printf "\${RED}Error: Please see --help command.\${DEF}\n" 1>&2
	exit 1
}

warn()
{
	printf "\${YEL}Warning: \$@\n\${DEF}" 1>&2

}

clean_main_files()
{
	rm mpc_main.c mpc_main.cxx mpc_main.f mpc_main.o > /dev/null 2>&1
}

build_main_files()
{
cat <<EOFINT > mpc_main.c
int i; 
int main(int argc, char** argv){
return 0;
}
EOFINT

cat <<EOFINT > mpc_main.cxx
int i;
int main(int argc, char** argv){
return 0;
}
EOFINT

cat <<EOFINT > mpc_main.f
        program main
        integer i
        end program
EOFINT
}

hash_content()
{
	\$CHECKSUM_TOOL \$1 | cut -f1 -d" "
}

format_path()
{
	#special case: '1' means 'first'
	test "x\$1" = "x1" && echo "\$1" && return
	which \$1 || die "\$1 not found"
}

is_valid_language()
{
	\echo "\$list_languages" | egrep -q " \$1 " || die "Language \${1} not known !"
}

create_home()
{
	test -n "\${user_prefix}" || die "Error occured when reading user_prefix in create_home()"
	test ! -d "\${user_prefix}" -o ! -w "\${user_prefix}" || die "Error occured when creating the HOME link"
	mkdir -p \${user_prefix}
	echo "\$MPC_RPREFIX" | sed -e "s#//*#/#g" > \${user_prefix}/mpc_install_path
	echo "\$CREATION_TIMESTAMP" > \${user_prefix}/.creation_timestamp
	cp \${MPC_RPREFIX}/.*_compilers.cfg \${user_prefix}/
	cp -r \${MPC_RPREFIX}/fortran_gen \${user_prefix}/
	for mylang in \$list_languages
	do
		#copy any existing directory for each language
		for line in \`cat \${user_prefix}/.\${mylang}_compilers.cfg | cut -f4 -d":"\`;
		do
			test -n "\$line" -a -d "\$MPC_RPREFIX/\$line/" && cp -r \${MPC_RPREFIX}/\$line  \$user_prefix/
		done
	done
}

is_valid_home()
{
	test -d "\$COMPILER_FILEPATH" || die "Sanity check failed !"
	test -f "\$COMPILER_FILEPATH/mpc_install_path" || die "Sanity check failed !"

	timestamp_f="\${COMPILER_FILEPATH}/.creation_timestamp"
	timestamp_v="\`cat \${timestamp_f} 2> /dev/null\`"
	#check existence for compatibility
	if test ! -f "\$timestamp_f" -o "\$CREATION_TIMESTAMP" != "\$timestamp_v"; then
		reinstall_date="\`date -u -d @\${CREATION_TIMESTAMP}\`"
		old_copy_date="\`date -u -d @\${timestamp_v}\`"
		warn "A more recent MPC configuration exists for this installation path:"
		warn "Local copy Timestamp: \${old_copy_date}"
		warn "New configuration Timestamp: \${reinstall_date}"
		warn "This may due to a MPC re-installation within the same prefix."
		backup="\${COMPILER_FILEPATH}-backup"
		test -d "\${backup}" && die "A previous backup exists. Please remove \${backup} directory first!"
		warn "The local copy is saved under \$backup."
		mv \${COMPILER_FILEPATH} \$backup
		create_home
	fi
}

help()
{
	printf "Usage: mpc_compiler_manager OPERATION LANGUAGE PATH FAMILY\n"
	printf "\n"
	printf "LANGUAGE belongs to {c,cxx,fortran} (default: c)\n"
	printf "PATH is the compiler path (default '1')\n"
	printf "FAMILY is the compiler type: INTEL, GNU... (default: GNU)\n"
	printf "OPERATION is one of the following:\n"
	printf "   \${BLU}list:\${DEF} shows, for each known compiler, the priv. support\n"
	printf "   \${BLU}stat:\${DEF} shows a summary for each language (number of compilers + priv. support)\n"
	printf "   \${BLU}list_default:\${DEF} list, for each language, the default compiler used\n"
	printf "   \n"
	printf "   \${BLU}add:\${DEF} adds a new compiler to the manager\n"
	printf "   \${BLU}del:\${DEF} removes a known compiler from the manager\n"
	printf "   \${BLU}set_default:\${DEF} set the given compiler as default (adds it first if not known)\n"
	printf "   \n"
	printf "   \${BLU}check:\${DEF} Verify compiler integrity against stored hash value.\n"
	printf "   \${BLU}help:\${DEF} Print this help.\n"
	printf "\n"
	printf "Extra options, which can be used in scripts to parse compilers:\n"
	printf "An special value for PATH can be set: '1' means 'the first compiler in the list'\n"	
	printf "   \${BLU}get:\${DEF} returns the compiler path if exist in configuration (lookup).\n"
	printf "   \${BLU}get_detail:\${DEF} like get, but returns all the data (lookup).\n"
	exit 0
}

#######################################
#for the following functions:
#\$1 = compiler path
#\$2 = privatization support
#\$3 = unique compiler hash

post_add_c()
{
	#nothing to do for now
	dummy=1
}
post_rm_c()
{
	#nothing to do for now
	dummy=1
}

post_add_cxx()
{
	#nothing to do for now
	dummy=1
}

post_rm_cxx()
{
	#nothing to do for now
	dummy=1
}

post_add_fortran()
{
	#rebuild Fortran modules and store them in HOME/.mpcompil/HASH
	test ! -f \$COMPILER_FILEPATH/fortran_gen/fortran_build.sh && die "Unable to generate Fortran module for \$1\n"
	printf "Compiling Fortran modules for the new compiler: \$1\n"


	#this is absolutely awful...
	#we have to build twice if compiler is privatizing => give *.mod for privatized or unprivatized usage.

	#build unprivatized usage
	FLAGS="-I\$MPC_prefix/include/mpcframework $SCTK_CFLAGS -L\$MPC_prefix/lib -L\${MPC_prefix}/lib64 -Wl,-rpath=\${MPC_prefix}/lib -Wl,-rpath=\${MPC_prefix}/lib64 $SCTK_LDFLAGS -B\$MPC_prefix/bin"
	CC="\`lookup_compiler c 1 | cut -f3 -d":"\` \$FLAGS -lmpc_framework -lmpc_tdb_remote_static"
	FC="\$1 \$FLAGS"
	mkdir -p \$COMPILER_FILEPATH/\$3/npriv
	MPC_MAKE_FORTRAN_INTERFACE=1 MPC_DISABLE_CONFIG=1 MPC_DISABLE_BANNER=1 sh \$COMPILER_FILEPATH/fortran_gen/fortran_build.sh "\$CC" "\$FC" "\$COMPILER_FILEPATH/fortran_gen/mpc_mpi.h" "\$COMPILER_FILEPATH/\$3/npriv"
	test "x\$?" != "x0" && die "Error(s) during Fortran module building for \$1"

	if test -n "\$2"; then
		#build privatized usage
		CC="\$CC \$2"
		FC="\$FC \$2"
		mkdir -p \$COMPILER_FILEPATH/\$3/priv
		MPC_MAKE_FORTRAN_INTERFACE=1 MPC_DISABLE_CONFIG=1 MPC_DISABLE_BANNER=1 sh \$COMPILER_FILEPATH/fortran_gen/fortran_build.sh "\$CC" "\$FC" "\$COMPILER_FILEPATH/fortran_gen/mpc_mpi.h" "\$COMPILER_FILEPATH/\$3/priv"
		test "x\$?" != "x0" && die "Error(s) during Fortran module building for \$1 w/ privatization support"
	fi

	#shortcut to identify the compiler matching the hash folder
	echo "\$1" >> \$COMPILER_FILEPATH/\$3/compiler
}

post_rm_fortran()
{
	test -n "\$3" -a -d "\$COMPILER_FILEPATH/\$3/" && rm -rf \$COMPILER_FILEPATH/\$3/
}

contains()
{
	do_contain="no"
	basename "\$1" | grep \$2 2>&1 > /dev/null

	if test "x\$?" = "x0"; then
		do_contain="yes"
	fi
}

infer_compiler_family()
{
	if test -n "\$compiler_family"; then
		#Family is set
		return
	fi

	# ICC family
	for comp in ifort icpc icc
	do
		contains \$1 \$comp
		if test "x\$do_contain" = "xyes"; then
			compiler_family="INTEL"
			return
		fi
	done

	#GNU family
	for comp in gcc gfortran g++
	do
		contains \$1 \$comp
		if test "x\$do_contain" = "xyes"; then
			compiler_family="GNU"
			return
		fi
	done

	#PGI family
	for comp in pgcc pgcpp pg++ pgfortran pgf77
	do
		contains \$1 \$comp
		if test "x\$do_contain" = "xyes"; then
			compiler_family="PGI"
			return
		fi
	done

	#LLVM family
	for comp in clang clang++ flang
	do
		contains \$1 \$comp
		if test "x\$do_contain" = "xyes"; then
			compiler_family="LLVM"
			return
		fi
	done
}

add_compiler()
{
	test "x\$2" = "x1" && die "Can't add a compiler if you don't provide a path."
	test -z "\`which \${2} 2> /dev/null\`" && die "\${2} not found. Not added."
	hash="\`hash_content \$2\`"

	# -r: extended regexes
	# -e: run script
	# -n: does not create output (only matching w/ /p)
	exists="\`get_compilers_in "\$1" | sed -n -e "\\,^\$3:.*:\${2}:.*$,p"\`"

	if test -n "\$exists"; then 
		old_hash="\`echo "\$exists" | cut -f4 -d":"\`"
		test "\$old_hash" = "\$hash" && return; #compiler exists and does not need to be updated
	fi

	#inserting the compiler
	build_main_files

	compiler_family=\$3
	infer_compiler_family \$2

	case \$compiler_family in
		GNU)
			PRIV_FLAG="-fmpc-privatize"
			;;
		INTEL)
			PRIV_FLAG="-mSYMTAB_mpc_privatize"
			;;
		PGI)
			PRIV_FLAG=""
			;;
		*)
			PRIV_FLAG=""
	esac

	ext=\${1}
	test "x\$ext" = "xfortran" && ext=f
	\${2} \${PRIV_FLAG} -c mpc_main.\${ext} > /dev/null 2>&1
	test "x\$?" != "x0" && PRIV_FLAG=""

	post_add_\${1} "\$2" "\$PRIV_FLAG" "\$hash"

	echo "\${compiler_family}:\${PRIV_FLAG}:\${2}:\${hash}" >> "\${COMPILER_FILEPATH}/.\${1}_compilers.cfg"
}

remove_compiler()
{
	test "x\$2" = "x1" && die "Can't remove a compiler if you don't provide a path."
	# -i: edit directly the file
	# -r: extended regexes
	# -e: exec script
	# "\,xxx,d": grep lines matching 'xxx' and remove them (using comma separator)
	sed -i -e "\\,^\$3:.*:\$2:.*$,d" \$COMPILER_FILEPATH/.\$1_compilers.cfg
	post_rm_\$1 "\$2" "" "\`hash_content \$2\`"
}

set_default_compiler()
{
	# -r: extended regexes
	# -e: run script
	# -n: does output (only matching w/ /p)
	exists="\`get_compilers_in "\$1" | sed -n -e "\\,^\$3:.*:\${2}:.*$,p"\`"
	
	#add it if not already done (add_compiler() does some extra stuff).
	if test -z "\$exists"; then
		add_compiler "\${1}" "\$2" "\$3"
		exists="\`tail -n 1 \${COMPILER_FILEPATH}/.\${1}_compilers.cfg\`"
	fi

	#set the compiler as the first one
	sed -ie "\\@\${exists}@d" \${COMPILER_FILEPATH}/.\${1}_compilers.cfg
	sed -i "1i \${exists}" \${COMPILER_FILEPATH}/.\${1}_compilers.cfg
}

stat_compilers()
{
	for language in \${list_languages}
	do
		lang_file=\${COMPILER_FILEPATH}/.\${language}_compilers.cfg
		nb_compilers="\`cat \${lang_file} | wc -l\`"
		nb_priv="\`cat \${lang_file} | cut -d":" -f2 | grep "^$" | wc -l\`"

		echo "MPC \${language} compiler supports \${GRE}\${nb_compilers}\${DEF} compilers, \${RED}\${nb_priv}\${DEF} of them are able to privatize."
	done
}

list_compilers()
{
	for line in \`get_all_compilers\`
	do
		family="\`echo \${line} | cut -d":" -f1\`"
		priv="\`echo \${line} | cut -d":" -f2\`"
		compiler="\`echo \${line} | cut -d":" -f3\`"
		hash="\`echo \${line} | cut -d":" -f4\`"

		if test -x \$compiler;
		then
			printf " * \${GRE}FOUND \${DEF}/"
			if test -n "\$priv";
			then
				printf "\${GRE} PRIV. SUPPORT OK \${DEF}"
			else
				printf "\${RED} NO PRIV. SUPPORT \${DEF}"
			fi
		else
			printf " * \${RED}NFOUND\${DEF}                   "
		fi

		printf "for (\${family}) \${compiler}\n"
	done
}

get_compilers_in()
{
	cat \${COMPILER_FILEPATH}/.\${1}_compilers.cfg
}

get_all_compilers()
{
	for language in \$list_languages
	do
		get_compilers_in \$language
	done
}

check_compilers()
{
	for line in \`get_all_compilers\`
	do
		compiler="\`echo \${line} | cut -d":" -f3\`"
		old_hash="\`echo \${line} | cut -d":" -f4\`"
		new_hash="\`hash_content \$compiler\`";
		if test "\$new_hash" != "\$old_hash"; then
			printf " * \${RED}MISMATCH\${DEF} hash"
		else
			printf " * \${GRE}Coherent\${DEF} hash"
		fi
		printf " for \$compiler\n"

	done
}

lookup_compiler()
{
	if test "\$2" = "1"; then #if the path is equal to 1 --> token: get first compiler
		get_first_compiler "\$1"
		return
	fi

	echo "\`get_compilers_in "\$1" | sed -n -e "\\,^.*:.*:\${2}:.*$,p"\`"
}

get_first_compiler()
{
	printf "\`head -n 1 \${COMPILER_FILEPATH}/.\${1}_compilers.cfg\`"
}

print_first_compilers()
{
	for language in \${list_languages}
	do
		printf " * Default \${BLU}\$language\${DEF} compiler: \`get_first_compiler \$language | cut -f3 -d":"\`\n"
	done
}

if test -n "\$MANAGER_COLOR"; then
RED="\`printf "\033[1;31m"\`"
GRE="\`printf "\033[1;32m"\`"
BLU="\`printf "\033[1;36m"\`"
YEL="\`printf "\033[1;33m"\`"
DEF="\`printf "\033[0;0m"\`"
fi

install_hash=\`echo \$MPC_RPREFIX | sed -e "s#//*#/#g" -e 's#/\$##g' | hash_content \`
user_prefix=\$HOME/.mpcompil/\$install_hash
COMPILER_FILEPATH=
ARGS=

for arg in \$@
do
	case \$arg in
		--local)
			COMPILER_FILEPATH="\$user_prefix"
			shift;
			;;
		--global)
			COMPILER_FILEPATH="\$MPC_RPREFIX"
			shift;
			;;
		*)
			ARGS="\$ARGS\$arg "
			shift;
			;;

	esac
done

#default values
command="help"
lang="c"
path="1"
family=""

#retrieve args
arg="\`echo "\$ARGS" | cut -s -d" " -f1\`"
test -n "\$arg" && command="\$arg"
arg="\`echo "\$ARGS" | cut -s -d" " -f2\`"
test -n "\$arg" && lang="\$arg"
arg="\`echo "\$ARGS" | cut -s -d" " -f3\`"
test -n "\$arg" && path="\`format_path "\$arg"\`"
arg="\`echo "\$ARGS" | cut -s -d" " -f4\`"
test -n "\$4" && family="\$arg"

is_valid_language "\$lang"

if test -z "\$COMPILER_FILEPATH"
then
	COMPILER_FILEPATH=\$user_prefix
	test ! -e \$user_prefix && create_home
fi

# do this check only when working this the local link
test "\$COMPILER_FILEPATH" != "\$MPC_RPREFIX" && is_valid_home
test ! -e \$COMPILER_FILEPATH/.\${lang}_compilers.cfg && touch \$COMPILER_FILEPATH/.\${lang}_compilers.cfg 

case "\$command" in
	help|-help|--help|h|-h|--h)
		help
		;;
	get|g)
		lookup_compiler "\$lang" "\$path" | cut -f3 -d":"
		exit 0 # get() is a special command for mpc_* wrappers
		;;
	get_detail)
		lookup_compiler "\$lang" "\$path"
		exit 0 # get_detail() is a special command for mpc_* wrappers
		;;
	add|+|a)
		add_compiler "\$lang" "\$path" "\$family"		
		printf " * Added to \$lang compilers: \$path\n"
		;;
	remove|rem|rm|r|delete|del|d|-)
		remove_compiler "\$lang" "\$path" "\$family"		
		printf " * Removed from \$lang compilers: \$path\n"
		;;
	default|def|set_default)
		set_default_compiler "\$lang" "\$path" "\$family"
		printf " * Set as \$lang default compiler: \$path\n"
		;;
	list|l)
		list_compilers
		;;
	list_first|lf|list_default|ld)
		print_first_compilers
		;;
	stat|-s)
		stat_compilers
		;;
	check|c)
		check_compilers
		;;
	config-path)
		echo "\$COMPILER_FILEPATH"
		exit 0
		;;
	*)
		die "Unknown rule: \"\$command\""
		;;
esac

printf "\nGlobal Info:\n"
printf "Read-only Installation located at \${BLU}\${MPC_RPREFIX}\${DEF}\n"
printf "Compiler Updates stored in \${GRE}\${COMPILER_FILEPATH}\${DEF}\n"

clean_main_files

exit 0
EOF
chmod 755 bin/mpc_compiler_manager
ln -sf mpc_compiler_manager bin/mpc_compiler_status
