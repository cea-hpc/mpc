#!/bin/sh

printf_compiler()
{
cat <<EOF > $1
#!/bin/sh
read_arg()
{
	echo "\$1" | sed -e "s@^\$2=@@"
}

die()
{
	for l in "\$@"
	do
		>&2 printf "Error: \$l\n"
	done
	exit 42
}

for arg in \$@
do
	case \$arg in
		*.proto)
			PROTO_FILE="\$arg"
			;;
		*.arpc)
			ARPC_FILE="\$arg"
			;;
		-config=*)
			FILE="\`read_arg "\$arg" "-config"\`"
			PROTO_FILE=\$FILE.proto
			ARPC_FILE=\$FILE.arpc
			;;
		-h|--h|-H|--H|-help|--help)
			printf "Help() needs to be written soon. Stay tuned\n"
			exit 0
			;;
		*)
			REST_OF_ARGS="\$REST_OF_AGS \$arg"
	esac
done

PROTOCC="protoc"
PROTOFLAGS="\`pkg-config --cflags --libs protobuf\`"

#reminder: Versions GCC-5 and above break libstdc++ ABI for std::string (copy-on-write impl.)
#This trick allow us to no check which compiler was used at Protobuf build
PROTOFLAGS="\$PROTOFLAGS -D_GLIBCXX_USE_CXX11_ABI=0"

which \$PROTOCC > /dev/null 2>&1 || die "Unable to find 'protoc' executable in \\\$PATH"
\$PROTOCC --cpp_out=\$PWD \$PROTO_FILE


test -f "\$ARPC_FILE" || die "No ARPC definition provided (*.arpc file)"
OUTFILE_H=\${PROTO_FILE//.proto/.pb.h}
OUTFILE_C=\${PROTO_FILE//.proto/.pb.cc}

LIST_OF_SERVICES="\`cat \$ARPC_FILE | egrep -v "^( *#.*| *)$" | cut -f1 -d"@" | sort -u \`"
srv_types="enum srv_type_e {"
for serv in \$LIST_OF_SERVICES; do srv_types="\$srv_types \${serv}_T,"; done
srv_types="\$srv_types __ARPC_SRV_TYPES_NB };"


#now build the ARPC C++ wrapper
cat<<EOF2 >> \$OUTFILE_H
#ifndef __ARPC_CXXW_H_
#define __ARPC_CXXW_H_
#include <list>
extern "C"
{
    #include <arpc.h>
}

namespace ARPC
{
\$srv_types
typedef ::sctk_arpc_context Context;
class Service
{
protected:
	srv_type_e _type;
public:
	Service(srv_type_e t) : _type(t) {}
	srv_type_e __type() { return _type;}
};

class ServicePool
{
private:
	std::map<srv_type_e, Service*> srv_array;
public:
	void add(Service* srv)
	{
		srv_array.insert(std::pair<srv_type_e,ARPC::Service*>(srv->__type(), srv));
	}

	Service* find(srv_type_e k)
	{
		return srv_array[k];
	}
};
EOF2


for serv in \$LIST_OF_SERVICES
do
	echo "namespace \${serv} {" >> \${OUTFILE_H}
	LIST_OF_RPCS="\`cat \$ARPC_FILE | egrep -v "^( *#.*| *)$" | grep -o "^\${serv}@.*"\`"
	send_code="
class Send : public Service
{
private:
public:
	Send() : Service(\${serv}_T){}
	virtual ~Send() {}
"
	recv_code="
class Recv : public Service
{
private:
public:
	Recv() : Service(\${serv}_T){}
	virtual ~Recv() {}
"

	for rpc in \$LIST_OF_RPCS
	do
		func="\`echo "\$rpc" | cut -d"@" -f2\`"
		input="\`echo "\$rpc" | cut -d"@" -f3\`"
		output="\`echo "\$rpc" | cut -d"@" -f4\`"
		
		resp_size="0"
		req_size="0"

		resp_parse=""
		req_parse=""
		
		if test "\$input" != "void"; then
			req_size="sizeof(\${input})"
			req_parse="
		std::string in;
		request->SerializeToString(&in);
		raw_req = in.c_str();
		"
		fi

		if test "\$output" != "void"; then
			resp_size="sizeof(\${output})"
			resp_parse="response->ParseFromString((char*)raw_resp);"
		fi

	recv_code="\$recv_code
	virtual bool \$func(Context* ctx, \${input}* request, \${output}* response) = 0;"

	send_code="\$send_code
	inline virtual bool \$func(Context* ctx, \${input}* request, \${output}* response)
	{
		const char* raw_req = NULL;
		void* raw_resp = NULL;
		int ret;
		size_t resp_size = \$resp_size, req_size = \$req_size;
	
		\$req_parse

		ret = arpc_emit_call(ctx, raw_req, req_size, &raw_resp, &resp_size);
		if(ret != 0) return ret;

		\$resp_parse

		return 0;
	}"
	done

	echo "\${send_code} };" >> \${OUTFILE_H}
	echo "\${recv_code} };" >> \${OUTFILE_H}

echo "}" >> \${OUTFILE_H}
done
echo "}
#endif" >> \${OUTFILE_H}

mpc_cxx -fno-mpc-privatize \$REST_OF_ARGS \${OUTFILE_C} \${PROTOFLAGS}
#rm \${OUTFILE_C} \${OUTFILE_H}

EOF
}

printf_compiler bin/mpc_arpcxx 
