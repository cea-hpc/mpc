#!/bin/sh

printf_compiler()
{
cat <<EOF > $1
#!/bin/sh
read_arg()
{
	echo "\$1" | sed -e "s@^\$2=@@"
}

die()
{
	for l in "\$@"
	do
		>&2 printf "Error: \$l\n"
	done
	exit 42
}

for arg in \$@
do
	case \$arg in
		*.proto)
			PROTO_FILE="\$arg"
			;;
		*.arpc)
			ARPC_FILE="\$arg"
			;;
		-config=*)
			FILE="\`read_arg "\$arg" "-config"\`"
			PROTO_FILE=\$FILE.proto
			ARPC_FILE=\$FILE.arpc
			;;
		-h|--h|-H|--H|-help|--help)
			printf "Help() needs to be written soon. Stay tuned\n"
			exit 0
			;;
		*)
			REST_OF_ARGS="\$REST_OF_ARGS \$arg"
	esac
done

PROTOCC="protoc"
PROTOFLAGS="\`pkg-config --cflags --libs protobuf\`"

#reminder: Versions GCC-5 and above break libstdc++ ABI for std::string (copy-on-write impl.)
#This trick allow us to no check which compiler was used at Protobuf build
PROTOFLAGS="\$PROTOFLAGS -D_GLIBCXX_USE_CXX11_ABI=0"

which \$PROTOCC > /dev/null 2>&1 || die "Unable to find 'protoc' executable in \\\$PATH"
\$PROTOCC --cpp_out=\$PWD \$PROTO_FILE


test -f "\$ARPC_FILE" || die "No ARPC definition provided (*.arpc file)"
OUTFILE_H=\${PROTO_FILE//.proto/.pb.h}
OUTFILE_C=\${PROTO_FILE//.proto/.pb.cc}

LIST_OF_SERVICES="\`cat \$ARPC_FILE | egrep -v "^( *#.*| *)$" | cut -f1 -d"@" | sort -u \`"
srv_types="enum srv_type_e {"
for serv in \$LIST_OF_SERVICES; do srv_types="\$srv_types \${serv}_T,"; done
srv_types="\$srv_types __ARPC_SRV_TYPES_NB };"


#now build the ARPC C++ wrapper
cat<<EOF2 >> \$OUTFILE_H
#ifndef __ARPC_CXXW_H_
#define __ARPC_CXXW_H_
#include <list>
extern "C"
{
    #include <arpc.h>
}

namespace ARPC
{
\$srv_types
typedef ::sctk_arpc_context Context;
class Service
{
protected:
	srv_type_e _type;
public:
	Service(srv_type_e t) : _type(t) {}
	srv_type_e __type() { return _type;}
};

class ServicePool
{
private:
	std::map<srv_type_e, Service*> srv_array;
public:
	void add(Service* srv)
	{
		srv_array.insert(std::pair<srv_type_e,ARPC::Service*>(srv->__type(), srv));
		arpc_register_service(srv->__type());
	}

	Service* find(srv_type_e k)
	{
		return srv_array[k];
	}
};
EOF2


for serv in \$LIST_OF_SERVICES
do
	echo "namespace \${serv} {" >> \${OUTFILE_H}
	LIST_OF_RPCS="\`cat \$ARPC_FILE | egrep -v "^( *#.*| *)$" | grep -o "^\${serv}@.*"\`"
	send_code="
class Send : public Service
{
private:
public:
	Send() : Service(\${serv}_T){ arpc_register_service(\${serv}_T);}
	virtual ~Send() {}
"
	recv_code="
class Recv : public Service
{
private:
public:
	Recv() : Service(\${serv}_T){}
	virtual ~Recv() {}
"
	converter_code="\${converter_code}
		case ARPC::\${serv}_T:
		{
			ARPC::\${serv}::Recv* r = (ARPC::\${serv}::Recv*) srv;
			switch(rpcode)
			{"
	i=0
	for rpc in \$LIST_OF_RPCS
	do
		func="\`echo "\$rpc" | cut -d"@" -f2\`"
		input="\`echo "\$rpc" | cut -d"@" -f3\`"
		output="\`echo "\$rpc" | cut -d"@" -f4\`"
		
		resp_size="0"
		req_size="0"

		resp_parse=""
		req_parse=""
		
		if test "\$input" != "void"; then
			req_size="request->SpaceUsed();"
			req_parse="
		std::string in;
		request->SerializeToString(&in);
		raw_req = in.c_str();
		req_size = in.size();
		"
		else
			req_size="0"
			req_parse="
			raw_req=NULL;
			"
		fi

		if test "\$output" != "void"; then
			resp_size="sizeof(\${output})"
			raw_resp="&raw_resp"
			resp_parse="
			if(resp_size > 0)
				response->ParseFromString((char*)raw_resp);
			else /* everything is zero and we didn't send anything */
				response->Clear();
			"
		else
			resp_size="0"
			resp_parse=""
			raw_resp="NULL"

		fi

	recv_code="\$recv_code
	virtual int \$func(Context* ctx, \${input}* request, \${output}* response) = 0;"

	send_code="\$send_code
	inline virtual int \$func(Context* ctx, \${input}* request, \${output}* response)
	{
		const char* raw_req = NULL;
		void* raw_resp = NULL;
		int ret;
		size_t req_size = \$req_size;
		size_t resp_size = \$resp_size;
	
		\$req_parse

		ctx->rpcode  = \${i};
		ctx->srvcode = \${serv}_T;
		ret = arpc_emit_call(ctx, raw_req, req_size, \$raw_resp, &resp_size);
		if(ret != 0) return ret;

		\$resp_parse

		return 0;
	}"


	req_parse=""
	resp_parse=""
	resp_serialize=""
	if test "\$input" != "void"; then
		req_parse="req = new \${input};
		if(req_size > 0)
			req->ParseFromString((char*)request);
		else
			req->Clear();
		"
	else
		req_parse=""
	fi

	if test "\$output" != "void"; then
		resp_parse="resp = new \${output};
		std::string out;"

		resp_serialize="resp->SerializeToString(&out);
		*response_addr=strdup(out.c_str());
		*resp_size=out.size();"
	else
		resp_parse="
		*resp_size=0;
		*response_addr=NULL;
		"
	fi
	converter_code="\${converter_code}
				case \$i: /* RPC \$func */
				{
					\${input}* req = NULL;
					\${output}* resp = NULL;

					\$req_parse
					\$resp_parse

					ret = r->\$func(ctx, req, resp);
					\$resp_serialize
					break;
				}"
	i="\`echo "\$i+1" | bc\`"
	done

	echo "\${send_code} };" >> \${OUTFILE_H}
	echo "\${recv_code} };" >> \${OUTFILE_H}

echo "}" >> \${OUTFILE_H}

converter_code="\${converter_code}
				default:
					std::cerr << \"Unknow RPC \" << rpcode << \"for Service \" << \"\${serv}\" << std::endl;
					std::abort();
					break;
				}
			break;
		}"
done
echo "}

int arpc_c_to_cxx_converter(sctk_arpc_context_t* ctx, const void * request, size_t req_size, void** response_addr, size_t* resp_size);
#endif" >> \${OUTFILE_H}

echo "
int arpc_c_to_cxx_converter(sctk_arpc_context_t* ctx, const void * request, size_t req_size, void** response_addr, size_t* resp_size)
{
	ARPC::ServicePool* pool = (ARPC::ServicePool*)ctx->cxx_pool;
	int ret = -1;
	ARPC::srv_type_e srvcode = (ARPC::srv_type_e)ctx->srvcode;
	int rpcode = ctx->rpcode;
	ARPC::Service* srv;
	
	if(!pool) return 1;

	srv = pool->find(srvcode);
	switch(srvcode)
	{\${converter_code}
		default:
			std::cerr << \"Unkown Service code \" << srvcode << std::endl;
			std::abort();
			break;
	}

	return ret;

}
" >> \${OUTFILE_C}

mpc_cxx -fno-mpc-privatize \$REST_OF_ARGS \${OUTFILE_C} \${PROTOFLAGS}
#rm \${OUTFILE_C} \${OUTFILE_H}

EOF
}

printf_compiler bin/mpc_arpcxx 
