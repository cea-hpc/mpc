#!/bin/sh
############################# MPC License ############################## 
# Wed Nov 19 15:19:19 CET 2008                                         # 
# Copyright or (C) or Copr. Commissariat a l'Energie Atomique          # 
#                                                                      # 
# IDDN.FR.001.230040.000.S.P.2007.000.10000                            # 
# This file is part of the MPC Runtime.                                # 
#                                                                      # 
# This software is governed by the CeCILL-C license under French law   # 
# and abiding by the rules of distribution of free software.  You can  # 
# use, modify and/ or redistribute the software under the terms of     # 
# the CeCILL-C license as circulated by CEA, CNRS and INRIA at the     # 
# following URL http://www.cecill.info.                                # 
#                                                                      # 
# The fact that you are presently reading this means that you have     # 
# had knowledge of the CeCILL-C license and that you accept its        # 
# terms.                                                               # 
#                                                                      # 
# Authors:                                                             # 
#   - PERACHE Marc marc.perache@cea.fr                                 # 
#   - CARRIBAULT Patrick patrick.carribault@cea.fr                     # 
#                                                                      # 
######################################################################## 


#
# Generate redirection to the main MPC compiler
# For suporting backard compatibility
#
# $1: the name of the deprecated script name
# $2: the real MPC script name
# $3: The (optional) argument to specifiy a compiler
printf_deprecated_compiler()
{
	echo "#!/bin/sh" > $1
	cat <<EOF >> $1
if test -z \${MPC_RPREFIX}; then
	echo "################################################################"
	echo "# No MPC_RPREFIX defined. it is the root of the actual prefix  #"
	echo "# Yout should source the mpcvars.sh file in root of MPC prefix #"
	echo "################################################################"
	exit 1
fi
EOF
	echo "#This script is deprecated, please use $2 instead" >> $1
	additional_compiler=""
	if test -n "$3"; then
		additional_compiler="-cc=$3"
	fi
	echo "\${MPC_RPREFIX}/\${MPC_HOST_SUBPREFIX}/\${MPC_TARGET_SUBPREFIX}/$2 $additional_compiler \"\$@\"" >> $1
}

#
# Generate redirection to the main MPC compiler
# For suporting backard compatibility
#
# $1: the name of the noflags script name
# $2: the real MPC script name
printf_noflags_compiler()
{
    echo "Generate $1"
	echo "#!/bin/sh" > $1
	cat <<EOF >> $1
if test -z \${MPC_RPREFIX}; then
	echo "################################################################"
	echo "# No MPC_RPREFIX defined. it is the root of the actual prefix  #"
	echo "# Yout should source the mpcvars.sh file in root of MPC prefix #"
	echo "################################################################"
	exit 1
fi
EOF
	echo "\${MPC_RPREFIX}/\${MPC_HOST_SUBPREFIX}/\${MPC_TARGET_SUBPREFIX}/$2 --use:command \"\$@\"" >> $1
}

#
# Generate redirection to the main MPC compiler
# For suporting backard compatibility
#
# $1: the name of the mpi script name
# $2: the real MPC script name
printf_mpi_compiler()
{
	echo "#!/bin/sh" > $1
	cat <<EOF >> $1
if test -z \${MPC_RPREFIX}; then
	echo "################################################################"
	echo "# No MPC_RPREFIX defined. it is the root of the actual prefix  #"
	echo "# Yout should source the mpcvars.sh file in root of MPC prefix #"
	echo "################################################################"
	exit 1
fi
EOF
	echo "\${MPC_RPREFIX}/\${MPC_HOST_SUBPREFIX}/\${MPC_TARGET_SUBPREFIX}/$2  \"\$@\"" >> $1
}

#
# Generate the main MPC compiler driver
#
# $1: target script (e.g., mpc_cc) 
# $2: target language (c, cxx or fortran)
#
printf_compiler(){

language="$2"
# Header
echo "#!/bin/sh" > $1
cat <<EOF >> $1
if test -z \${MPC_RPREFIX}; then
	echo "################################################################"
	echo "# No MPC_RPREFIX defined. it is the root of the actual prefix  #"
	echo "# Yout should source the mpcvars.sh file in root of MPC prefix #"
	echo "################################################################"
	exit 1
fi

die()
{
	printf "Error: \$@\n" 1>&2
	exit 2
}

#used to override option w/ compiler specific when option has been provided
# \$1: var name
# \$2: compiler-specific option
override_var_if_isset()
{
	content="\`eval echo "$"\${1}\`"
	if [ ! -z "\${content}" ]
	then
		content="\${2}"
	else
		content=""
	fi

	eval "\${1}=\${content}"
}

print_if_stdout()
{
    >&2 printf "\$@"
}

#Used by nvcc to automatically blacklist some var patterns
preprocess_main()
{
EOF
if test "$1" = "bin/mpc_nvcc"
then
cat <<EOF >> $1
CUDA_FILE="/tmp/cuda_tmp_main\${RANDOM}.cu"
cat<< EOF_FILE > \${CUDA_FILE}
#include <stdlib.h>

__global__
void foo(void)
{
}

int main(int argc, char ** argv)
{
	return 0;
}
EOF_FILE

IFS="
"

tmp=""
for decl in \`nvcc -ccbin \${CC} \${CFLAGS} -Xcompiler -fmpc-privatize \${CUDA_FILE} -Xcompiler -B\${MPC_RPREFIX}/\${MPC_HOST_SUBPREFIX}/\${MPC_TARGET_SUBPREFIX}/bin 2>&1 | grep "MPC task" | sed -e 's/.*variable //g' -e 's/ in file.*//g'\`
do
	tmp="\${tmp}:\${decl}"
done

echo "\${tmp}"
rm \${CUDA_FILE}
EOF
else
cat <<EOF >> $1
echo ""
EOF
fi
cat <<EOF >> $1
}
EOF
header_sh >> $1

########################################
########################################
####### MPC COMPIL WRAPPER GEN #########
########################################
########################################

# For Fortran, generate a small object w/ main routine
if test "$2" = "fortran" ; then 
cat <<EOF >> $1
FORTRAN_START="/tmp/tmp_mpc_fortran_\$\$.f"
FORTRAN_OBJ="/tmp/tmp_mpc_fortran_\$\$.o"

#echo "\$FORTRAN_START \$FORTRAN_OBJ"

cat <<THIS_EOF > \$FORTRAN_START
! ############################# MPC License ##############################
! # Wed Nov 19 15:19:19 CET 2008                                         #
! # Copyright or (C) or Copr. Commissariat a l'Energie Atomique          #
! #                                                                      #
! # IDDN.FR.001.230040.000.S.P.2007.000.10000                            #
! # This file is part of the MPC Runtime.                                #
! #                                                                      #
! # This software is governed by the CeCILL-C license under French law   #
! # and abiding by the rules of distribution of free software.  You can  #
! # use, modify and/ or redistribute the software under the terms of     #
! # the CeCILL-C license as circulated by CEA, CNRS and INRIA at the     #
! # following URL http://www.cecill.info.                                #
! #                                                                      #
! # The fact that you are presently reading this means that you have     #
! # had knowledge of the CeCILL-C license and that you accept its        #
! # terms.                                                               #
! #                                                                      #
! # Authors:                                                             #
! #   - PERACHE Marc marc.perache@cea.fr                                 #
! #   - CARRIBAULT Patrick patrick.carribault@cea.fr                     #
! ########################################################################
      subroutine mpc_user_main_
      call mpc_user_main()
      end

      program main
      call mpc_start()
      call exit(0)
      end
THIS_EOF
FFLAGS="$SCTK_FFLAGS"
MPC_COMPILER_CFLAGS=
EOF
else
cat <<EOF >> $1
FFLAGS=
MPC_COMPILER_CFLAGS="$MPC_COMPILER_CFLAGS"
EOF
fi



# More variable definitions (Library path, show and different shades of args)
cat << EOF >> $1
MPC_MANAGER=\$MPC_RPREFIX/\$MPC_SUBPREFIX/bin/mpc_compiler_manager
HOME_FILEPATH=\$MPC_RPREFIX
CC="\`\$MPC_MANAGER get $2 1\`"
#LIB_PATH="-Wl,-rpath,\${MPC_RPREFIX}/\${MPC_TARGET_SUBPREFIX}/\${MPC_TARGET_SUBPREFIX}/lib ${LIB_PATH}"
if test "\$MPC_MAKEFILE" != "" ; then 
LIB_PATH=""
fi
config_temp=\`\$MPC_MANAGER config-path\`
if test -r \$config_temp; then
	HOME_FILEPATH=\$config_temp
fi

# This variable is updated to 'echo' when '-show' is active
Show=eval

# Do we have to link eventually?
linking=yes

# All args concerning the compiling process (w/out mpc_cc-related options)
allargs=""

# Name of the output filename if the option '-o' is set
output_filename=""
output_file=""
next_arg_is_output=no
OUTPUT_FILE_ARGS=""
PRIV_FLAG="-fmpc-privatize"
EXTRA_ADDON_FLAGS=""
EOF

if test "$1" = "bin/mpc_nvcc"
then
cat<<EOF >> $1
EXTRA_ADDON_FLAGS="-L\$MPC_RPREFIX/\${MPC_SUBPREFIX}/lib/stubs -Wl,-rpath=\$MPC_RPREFIX/\${MPC_SUBPREFIX}/lib/stubs -lmpc_cuda_addon -Wl,--unresolved-symbols=ignore-in-shared-libs"
EOF
fi

cat<<EOF >> $1
unset MPC_DISABLE_TLS_OPT
NO_TLS_OPT=0
MPC_HEADER_INCLUDE="-include mpc_main.h"
OMP_FLAG=""
EOF
if  test "$language" = "c"; then

cat << EOF >> $1
#By default enable dynamic pricatization
export MPC_DYN_PRIV_ENABLED=1
EOF

fi

cat << EOF >> $1
for arg in "\$@" ; do
    # Set addarg to no if this arg should be ignored by the C compiler
    addarg=yes
    qarg=\$arg

    if [ \$next_arg_is_output = yes ] ; then
      output_filename=\$qarg
      next_arg_is_output=no
      OUTPUT_FILE_ARGS="-o \$qarg"

#       allargs="\$allargs \$qarg"
      continue
    fi

    case \$arg in
        # ----------------------------------------------------------------
        # Compiler options that affect whether we are linking or not
    -c|-S|-E|-M|-MM)
    # The compiler links by default
    linking=no
    ;;

    -cc=*)
    CC=\`echo A\$arg | sed -e 's/^A-cc=//g'\`
	CC=\`which \${CC} || echo \${CC}\`
    addarg=no
    MPC_COMPILER_CFLAGS=""
    ;;

    -o)
    next_arg_is_output=yes
    addarg=no
    ;;

    -threads)
    CFLAGS="\$CFLAGS -threads"
    ;;
--showme:link)
SHOW_LINK="1"
SHOW_ARGS="1"
		addarg=no
;;
--showme:compile)
SHOW_COMPILE="1"
SHOW_ARGS="1"
		addarg=no
;;
--showme:command)
SHOW_COMMAND="1"
SHOW_ARGS="1"
		addarg=no
;;
--use:command)
USE_COMMAND="1"
		addarg=no
;;
	-fmpc-privatize|-fmpcprivatize|-f-mpc-privatize)
		PRIV_FLAG="\$arg"
    	addarg=no
	;;  
	-fno-mpc-privatize|-fno-mpc-privatize|-fnompc-privatize|-fnompcprivatize)
		PRIV_FLAG=""
		addarg=no
	;;
	-fno-mpc-plugin)
		unset MPC_DYN_PRIV_ENABLED
		addarg=no
	;;
	-fmpc-dyninsert|-fmpc-dyn-insert)
		export MPC_DYN_INSERT=1
		addarg=no
	;;
	-fmpc-notlsopt|-fmpc-no-tlsopt)
		NO_TLS_OPT=1
		addarg=no
	;;
	-fmpc-include)
		#nothing to do, if not fortran, '-include mpc_main.h' is automatically forwarded
		#This is due to order : '-include' should be set after sources files
		MPC_HEADER_INCLUDE="-include mpc_main.h"
		addarg=no
	;;
	-fno-mpc-include)
		MPC_HEADER_INCLUDE=""
		addarg=no
	;;
	-fopenmp|-openmp)
		OMP_FLAG="\$arg"
		addarg=no
	;;
	-fno-openmp|-fnoopenmp|-no-openmp|-noopenmp)
		OMP_FLAG=""
		addarg=no
	;;
	-compilers|--compilers)
		content="\`\$MPC_MANAGER list 2>&1\`"
		print_if_stdout "\$content\n"
		exit 0
		;;
	-target_list|--target_list)
		uname=\`uname -m\`
		target_list_tmp="\`ls -A \${MPC_RPREFIX}/\`"
		for d in \`echo \$target_list_tmp\`; 
		do
			if test -d "\${MPC_RPREFIX}/\${d}"; then
				target_list="\${target_list} \${d}"
			fi
		done
		for d in \`echo \${target_list}\`; 
		do
			if test "\${d}" != "\${uname}"; then
				echo "\${d}"
			fi
		done
		exit 0
	;;
	-cuda)
		EXTRA_ADDON_FLAGS="-L\$MPC_RPREFIX/\${MPC_SUBPREFIX}/lib/stubs -Wl,-rpath=\$MPC_RPREFIX/\${MPC_SUBPREFIX}/lib/stubs -lmpc_cuda_addon -Wl,--unresolved-symbols=ignore-in-shared-libs"
		addarg=no
	;;
	-target=*)
	TARGET=\`echo A\$arg | sed -e 's/A-target=//g'\`
	addarg=no
	
	echo "loading \${TARGET} options..."
	if test -f "`echo "\\${MPC_RPREFIX}/\${MPC_TARGET_SUBPREFIX}/\${MPC_TARGET_SUBPREFIX}" | sed -re 's#'"${MPC_HOST}"'|'"${MPC_TARGET}"'#\${TARGET}#g'`/.target_options"; then
		. `echo "\\${MPC_RPREFIX}/\${MPC_TARGET_SUBPREFIX}/\${MPC_TARGET_SUBPREFIX}" | sed -re 's#'"${MPC_HOST}"'|'"${MPC_TARGET}"'#\${TARGET}#g'`/.target_options
		cat `echo "\\${MPC_RPREFIX}/\${MPC_TARGET_SUBPREFIX}/\${MPC_TARGET_SUBPREFIX}" | sed -re 's#'"${MPC_HOST}"'|'"${MPC_TARGET}"'#\${TARGET}#g'`/.target_options
	else
		echo "This architecture is not supported"
		exit 1
	fi
    ;;

    -show)
    addarg=no
    Show=echo
    ;;

    # Verbose mode
    -v)
    # Pass this argument to the pre-compiler/compiler as well.
    echo "mpc_cc for \$MPC_VERSION"
    ;;

    # Help
    -help)
    ;;

    *)
	qarg="'\$arg'"
    ;;

    esac

    # Update compiler arguments
    if [ \$addarg = yes ] ; then
        # Thanks to Bernd Mohr for the following that handles quotes and spaces (see configure for explanation)
        modarg=\`echo "x\$arg" | sed -e 's/^x//' -e 's/"/\\\\\"/g' -e s,\',%@%\',g -e 's/%@%/\\\\\/g' -e 's/ /\\\\\ /g' -e 's#(#\\\\\(#g' -e 's#)#\\\\\)#g'\`
        allargs="\$allargs \$modarg"
    fi
done

if test "\$USE_COMMAND" = "1"; then 
MPC_HEADER_INCLUDE=""
PRIV_FLAG=""
fi 
EOF
if [ "$2" != "fortran" ];
then
cat << EOF >> $1
allargs="\${allargs} \${MPC_HEADER_INCLUDE}"
EOF
fi
cat << EOF >> $1
is_defined="\`\$MPC_MANAGER get_detail $2 \${CC}\`"

#if CC is not present in MPC compiler configuration file
if test -z "\${is_defined}";
then
        if test "$SCTK_MPC_PROCESS_MODE" = "1" ; then 
                PRIV_FLAG=""
        else
		print_if_stdout "Warning: \${CC} not known: Adding it\n"
		\${MPC_RPREFIX}/\${MPC_SUBPREFIX}/bin/mpc_compiler_manager add $2 "\${CC}" > /dev/null
		test "x\$?" != "x0" && die "Unable to add \$CC (because of errors above). Stop."
		is_defined="\`\$MPC_MANAGER get_detail $2 \${CC}\`"
        fi
fi

CC_FAMILY="\`echo \${is_defined} | cut -d":" -f1\`"
CC_PRIV="\`echo \${is_defined} | cut -d":" -f2\`"
CC="\`echo \${is_defined} | cut -d":" -f3\`"
CC_HASH="\`echo \${is_defined} | cut -d":" -f4\`"

#if CC does not support privatization and user provides privatization option
if test -n "\${PRIV_FLAG}" -a -z "\${CC_PRIV}";
then
if test "$SCTK_MPC_PROCESS_MODE" != "1" ; then 
	print_if_stdout "Warning: '\${CC}' does not support privatization. Disabling it.\n"
	print_if_stdout "Warning: Do not consider using this compiler in thread-based mode.\n"
fi
	PRIV_FLAG=""
else
	#handle compiler-specific options depending on compiler family
	case \${CC_FAMILY} in
		INTEL)
			override_var_if_isset 'PRIV_FLAG' '-mSYMTAB_mpc_privatize'
			override_var_if_isset 'OMP_FLAG' '-qopenmp'
        		FFLAGS="\${FFLAGS} -threads -recursive"
			MPC_USE_INTEL_COMPILER="1"
			export MPC_USE_INTEL_COMPILER
			;;
		GNU)
EOF

#Insert a reference to the privatization plugin
if [ "$language" = "c" ]; then
cat << EOF >> $1
		#a getenv() is not enough to disable the plugin: better to skip the option
		if test -e \${MPC_RPREFIX}/\${MPC_HOST_SUBPREFIX}/\${MPC_TARGET_SUBPREFIX}/lib/libprivplug.so -a -n "\$MPC_DYN_PRIV_ENABLED";
		then
			LIBPRIV_FLAG="-fplugin=\${MPC_RPREFIX}/\${MPC_HOST_SUBPREFIX}/\${MPC_TARGET_SUBPREFIX}/lib/libprivplug.so"
		else
			LIBPRIV_FLAG=""
		fi
EOF
fi

#Insert the Getopt.h include if not in Fortran
if [ "$language" != "fortran" ]; then
cat << EOF >> $1
		if test -e "\${MPC_RPREFIX}/\${MPC_HOST_SUBPREFIX}/\${MPC_TARGET_SUBPREFIX}/lib/libmpcgetopt.a"; 
		then
			GETOPT_FLAG="-include \${MPC_RPREFIX}/\${MPC_HOST_SUBPREFIX}/\${MPC_TARGET_SUBPREFIX}/include/getopt.h"
		else
			GETOPT_FLAG=""
		fi
EOF
fi


cat << EOF >> $1
			override_var_if_isset 'PRIV_FLAG' '-fmpc-privatize'
			override_var_if_isset 'OMP_FLAG' '-fopenmp'
			;;
		*)
			#Nothing to do, vars set by user option
			;;
	esac
fi

#Do we need to disable TLS optimizations ?
if test "x\${NO_TLS_OPT}" = "x1"; then
	echo "INFO : TLS optimization disabled" 1>&2
	export MPC_DISABLE_TLS_OPT=1
fi

#we need to add -DMPC_PRIVATIZED when privatisation is enabled in order to compile deps (like getopt...)
if test ! -z "\${PRIV_FLAG}";
then
	CC_HASH="\$CC_HASH/priv"
	PRIV_FLAG="\${PRIV_FLAG} -DMPC_PRIVATIZED"
else
	#Without privatization the plugin is useless
	LIBPRIV_FLAG=""
	CC_HASH="\$CC_HASH/npriv"
fi

#Here we prepend the path which is normally postpended in order
#to override binutils during the compilation
export PATH=\${MPC_RPREFIX}/\${MPC_HOST_SUBPREFIX}/\${MPC_TARGET_SUBPREFIX}/bin/:\${PATH}

#Used to avoid header global variable privatization when libraries are not privatized
#mpcmp.h and mpcmicrothread.h have been recopied from GCC patch
MPC_UNPRIVATIZED_FILES="\${MPC_UNPRIVATIZED_FILES}:mpcmp.h:mpcmicrothread.h:ompt.h:"
MPC_UNPRIVATIZED_VARS="\${MPC_UNPRIVATIZED_VARS}:\`preprocess_main\`"

custompath=""
EOF


if test "$2" = "fortran" ; then 

cat <<EOF >> $1
custompath="\$HOME_FILEPATH/\$CC_HASH/"
MPC_UNPRIVATIZED_VARS="\${MPC_UNPRIVATIZED_VARS}:mpi_status_ignore:mpi_statuses_ignore:mpi_in_place"
EOF

fi

cat <<EOF >> $1

export MPC_UNPRIVATIZED_FILES
export MPC_UNPRIVATIZED_VARS

#first definition of compiler & linking flags
CFLAGS="\`\${MPC_RPREFIX}/\${MPC_HOST_SUBPREFIX}/\${MPC_TARGET_SUBPREFIX}/bin/mpc_cflags $language \$custompath\`"
LDFLAGS="\`\${MPC_RPREFIX}/\${MPC_HOST_SUBPREFIX}/\${MPC_TARGET_SUBPREFIX}/bin/mpc_ldflags $language \$custompath\`"
LDFLAGS="\$EXTRA_ADDON_FLAGS \$LDFLAGS"


EOF
# Regular flags and compiler (C, C++ or fortran)
if test "${BINUTILS_PREFIX}" != "disabled" ;
then
cat <<EOF >> $1
#override flags when patched binutils are used
LDFLAGS="\${LDFLAGS} -B\${MPC_RPREFIX}/\${MPC_HOST_SUBPREFIX}/\${MPC_TARGET_SUBPREFIX}/bin"
EOF
fi

if test "$1" = "bin/mpc_nvcc"
then
cat<<EOF >> $1
LDFLAGS="\`echo "\$LDFLAGS" | sed -e 's/\-Wl,/-Xlinker /g' -e 's/ -B/ -Xcompiler &/g'\`"
if test -n "\${PRIV_FLAG}"
then
	PRIV_FLAG="-Xcompiler \${PRIV_FLAG}"
fi
if test -n "\${OMP_FLAG}"
then
	PRIV_FLAG="-Xcompiler \${OMP_FLAG}"
fi
EOF
fi

cat << EOF >> $1
#used to append compiler-specific flags
CFLAGS="\$CFLAGS \${PRIV_FLAG} \${OMP_FLAG} \$MPC_COMPILER_CFLAGS \${LIBPRIV_FLAG} \${GETOPT_FLAG}"
CFLAGS_FORTRAN_START="\${PRIV_FLAG} \$MPC_COMPILER_CFLAGS \${LIBPRIV_FLAG} \${GETOPT_FLAG}"
LDFLAGS="\${LDFLAGS}"

if [ "\$linking" = yes ] ; then
EOF

if test "$2" = "fortran" ; then 
cat <<EOF >> $1
    \$Show \$CC \$FFLAGS \$CFLAGS_FORTRAN_START -c \$FORTRAN_START -o \$FORTRAN_OBJ
    rc=\$?
    if test "\$rc" != "0" ; then 
        exit \$rc
    fi

    # FROM HERE, We want to replace main() fortran symbol in each fortran file (object or source)
    # 3 cases occur
    # - at least one .o exposes a symbol MAIN -> to be replaced and FORTRAN_OBJ has to be loaded
    # - at least one .o exposes a symbol mpc_user_main -> nothing to do but FORTRAN_OBJ has to be loaded
    # - No .o do not provide any MAIN* symbol -> remove FORTRAN_OBJ, nothing indicating its a program (lib?)

    ##########################################
    # Check if object in \$1 contains symbol \$2
    has_symbol ()
    {
	    if test -f "\${1}"
	    then
		    # nm -P -> Posix formating (start w/ symbol name)
		    nb=\`nm -P "\${1}" | egrep "^\${2} " | wc -l\`
		    if test "x\${nb}" = "x1"
		    then
			    HAS_SYMBOL=1
			    return
		    fi
	    fi

	    HAS_SYMBOL=0
    }

    ##########################################
    # Replace symbol \$2 by \$3 for the object file \$1
    rename_sym ()
    {
	    objcopy --redefine-sym \${2}=\${3} "\${1}"
    }

    ##########################################
    # Replace any main* symbol in \$1 object file.
    # this includes:
    # - the MAIN call
    # - any outlined OpenMP rountines, which could be located in MAIN function
    rename_main_symbols ()
    {
	    # rename the MAIN
	    rename_sym "\${1}" "MAIN__" "mpc_user_main_"
	    objcopy --globalize-symbol="mpc_user_main_" "\${1}"

	    #rename OpenMP outlined routines
	    index=0
	    has_symbol "\${1}" "MAIN__._omp_fn.\${index}"

	    while test "x\${HAS_SYMBOL}" = "x1"
	    do
		    rename_sym "\${1}" "MAIN__._omp_fn.\${index}" "mpc_user_main_._omp_fn.\${index}"
		    index=\`expr \${index} + 1\`

		    has_symbol "\${1}" "MAIN__._omp_fn.\${index}"

	    done

	    # Remove the main
	    objcopy --strip-symbol main "\${1}"
    }

    ##########################################
    # Checks if the \$1 file ends with \$2 (return 0 means "OK it's good")
    has_ext ()
    {
	    case "\$1" in
		    *\$2) return 0;;
		    *) return 1;;
	    esac
    }
    
    MAIN_NEEDED=0
    SOURCE_FILES=""
    OBJECT_FILES=""
    ARGS_NO_SOURCES=""
    # First walk through objects and modify the main one and identify sourcefiles given on link command line
    for arg in \$allargs
    do
	    addarg=1
	    unquotedarg="\$(eval echo \$arg)"
	    #Is it a file ?
	    if test -f "\$unquotedarg"
	    then
		    #Is is an object file ?
		    if has_ext "\${unquotedarg}" ".o"
		    then
			    #It is an object file, but is it the real main ?
			    has_symbol "\${unquotedarg}" "MAIN__"
			    if test "x\${HAS_SYMBOL}" = "x1"
			    then
				    MAIN_NEEDED=1
				    #This is main, rename the symbol(s)
				    \$Show rename_main_symbols "\${unquotedarg}"

			    else # Ok, not a real MAIN__ symbol but what about mpc_user_main_ ? (backward compatibility)
				    # In this case, we need FORTRAN_OBJ but not to rename the main() symbol
				    has_symbol "\${unquotedarg}" "mpc_user_main_"
				    test "x\${HAS_SYMBOL}" = "x1" && MAIN_NEEDED=1
			    fi
		    else
			    #This is a file, but not an object... is it a Fortran source file ?
			    for ext in .f .F .f90 .F90 .f08 .F08 .for .FOR .fpp .FPP .r
			    do
				    if has_ext "\${unquotedarg}" "\${ext}"
				    then
					    addarg=0
					    # This is a Fortran source file, store it...
					    SOURCE_FILES="\${SOURCE_FILES} \${unquotedarg}"
					    break
				    fi
			    done
		    fi
	    fi
	    if [ \${addarg} -eq 1 ]
	    then
		    ARGS_NO_SOURCES="\${ARGS_NO_SOURCES} \${arg}"
	    fi
    done

    if test "\$SHOW_ARGS" = "1" ; then 
	    if test "\$SHOW_COMPILE" = "1"; then 
		    echo \$FFLAGS \$CFLAGS
	    fi 
	    if test "\$SHOW_LINK" = "1"; then 
		    echo \$LIB_PATH \$LDFLAGS
	    fi 
	    if test "\$SHOW_COMMAND" = "1"; then 
		    echo $3\$CC
	    fi 
    else
	    if test "\$USE_COMMAND" = "1"; then 
		    LIB_PATH=""
		    LDFLAGS=""
		    CFLAGS=""
		    FFLAGS=""
	    fi 
	    # If there are some source files on command line
	    if test -n "\${SOURCE_FILES}"
	    then
		    for source_file in \${SOURCE_FILES}
		    do
			    object_file=\$(mktemp --suffix=.o)
			    \$Show \$CC \$LIB_PATH \$LDFLAGS \$FFLAGS \$CFLAGS \${ARGS_NO_SOURCES} \$LDFLAGS "\${source_file}" -c -o "\${object_file}"
			    # Is this object (ie. source file) owning a real main symbol ?
			    has_symbol "\${object_file}" "MAIN__"
			    if test "x\${HAS_SYMBOL}" = "x1"
			    then
				    #This is main, rename the symbol(s) (not reached is Show is echo...)
				    MAIN_NEEDED=1
				    \$Show rename_main_symbols "\${object_file}"
			    
			    else # Ok, not a real MAIN__ symbol but what about mpc_user_main_ ? (backward compatibility)
				    # In this case, we need FORTRAN_OBJ but not to rename the main() symbol
				    has_symbol "\${object_file}" "mpc_user_main_"
				    test "x\${HAS_SYMBOL}" = "x1" && MAIN_NEEDED=1
			    fi
			    OBJECT_FILES="\${OBJECT_FILES} '\${object_file}'"
		    done
	    fi

	    if test "x\${MAIN_NEEDED}" = "x0"
	    then
		    #No main() ? probably a lib or module to build -> no need to inject FORTRAN_OBJ
		    FORTRAN_OBJ=""
	    fi
	    #otherwise, FORTRAN_OBJ discard user MAIN() and create a new one calling mpc_start()

	    \$Show \$CC \$LIB_PATH \$FORTRAN_OBJ \$LDFLAGS \$FFLAGS \$CFLAGS \$ARGS_NO_SOURCES \${OBJECT_FILES} \$LDFLAGS \${OUTPUT_FILE_ARGS}
	    rc=\$?
	    \$Show rm -f \$FORTRAN_OBJ \${OBJECT_FILES} \$FORTRAN_START
	    if test "\$rc" != "0" ; then
		    exit \$rc
	    fi
    fi
EOF
else
cat <<EOF >> $1
if test "\$SHOW_ARGS" = "1" ; then 
if test "\$SHOW_COMPILE" = "1"; then 
echo \$CFLAGS
fi 
if test "\$SHOW_LINK" = "1"; then 
echo \$LIB_PATH \$LDFLAGS
fi 
if test "\$SHOW_COMMAND" = "1"; then 
echo $3\$CC
fi 
else
if test "\$USE_COMMAND" = "1"; then 
LIB_PATH=""
LDFLAGS=""
CFLAGS=""
fi 
    \$Show $3\$CC \$LIB_PATH \$LDFLAGS \$CFLAGS \$allargs \$LDFLAGS \${OUTPUT_FILE_ARGS} 
fi
    # The first \$LDFLAGS should be removed, but still some issues... 
    # \$Show \$CC \$LIB_PATH \$CFLAGS \$allargs \$LDFLAGS \${OUTPUT_FILE_ARGS} 
    rc=\$?
EOF
fi

if test "$2" = "fortran" ; then 
cat <<EOF >> $1
    \$Show rm -f \$FORTRAN_OBJ
EOF
fi

cat <<EOF >> $1
else
EOF
if test "$2" = "fortran" ; then 
cat <<EOF >> $1
    \$Show \$CC \$FFLAGS \$CFLAGS \$allargs \${OUTPUT_FILE_ARGS}
    rc=\$?
EOF
else
cat <<EOF >> $1
    \$Show $3\$CC \$CFLAGS \$allargs \${OUTPUT_FILE_ARGS}
    rc=\$?
EOF
fi
cat <<EOF >> $1
fi

EOF

if test "$2" = "fortran" ; then 
cat <<EOF >> $1
rm -f \$FORTRAN_START > /dev/null 2>&1 
EOF
fi 

cat << EOF >> $1

exit \$rc

EOF

chmod 755 $1

} # end of printf_compiler()

#############################################################
#############################################################
############ START COMPILER WRAPPER GENERATION ##############
#############################################################
#############################################################

#fill target options for mpc_cc
#for the host
if test "`echo ${MPC_RPREFIX}/${MPC_TARGET_SUBPREFIX}/${MPC_TARGET_SUBPREFIX}/ | grep "${SCTK_ARCH}"`" = ""; then
	if test ! -d "${MPC_RPREFIX}/${MPC_TARGET_SUBPREFIX}/${MPC_TARGET_SUBPREFIX}/"; then
			mkdir -p "${MPC_RPREFIX}/${MPC_TARGET_SUBPREFIX}/${MPC_TARGET_SUBPREFIX}/"
	fi
	
	if test -f "\${MPC_RPREFIX}/\${MPC_TARGET_SUBPREFIX}/\${MPC_TARGET_SUBPREFIX}/.target_options"; then
		rm "${MPC_RPREFIX}/${MPC_TARGET_SUBPREFIX}/${MPC_TARGET_SUBPREFIX}/.target_options"
		touch "${MPC_RPREFIX}/${MPC_TARGET_SUBPREFIX}/${MPC_TARGET_SUBPREFIX}/.target_options"
	else
		touch "${MPC_RPREFIX}/${MPC_TARGET_SUBPREFIX}/${MPC_TARGET_SUBPREFIX}/.target_options"
	fi
	case `uname -m` in
		x86_64)
cat <<EOF >> "${MPC_RPREFIX}/${MPC_TARGET_SUBPREFIX}/${MPC_TARGET_SUBPREFIX}/.target_options"
#!/bin/sh
SCTK_MIC=0
export SCTK_MIC
CC=\`\${MPC_RPREFIX}/\$MPC_SUBPREFIX}/bin/mpc_compiler_manager get c 1\`
export CC
addarg=no
CFLAGS="\`\${MPC_RPREFIX}/\${MPC_TARGET_SUBPREFIX}/\${MPC_TARGET_SUBPREFIX}/bin/mpc_cflags c\`"
export CFLAGS
LDFLAGS="\`\${MPC_RPREFIX}/\${MPC_TARGET_SUBPREFIX}/\${MPC_TARGET_SUBPREFIX}/bin/mpc_ldflags c\`"	
export LDFLAGS
EOF
		;;
		k1om)
cat <<EOF >> "${MPC_RPREFIX}/${MPC_TARGET_SUBPREFIX}/${MPC_TARGET_SUBPREFIX}/.target_options"
#!/bin/sh
SCTK_MIC=1
export SCTK_MIC
CC=icc
export CC
addarg=no
CFLAGS="\`\${MPC_RPREFIX}/\${MPC_TARGET_SUBPREFIX}/\${MPC_TARGET_SUBPREFIX}/bin/mpc_cflags c\` -mmic"
export CFLAGS
LDFLAGS="\`\${MPC_RPREFIX}/\${MPC_TARGET_SUBPREFIX}/\${MPC_TARGET_SUBPREFIX}/bin/mpc_ldflags c\` -mmic -B\${MPC_RPREFIX}/\${MPC_HOST_SUBPREFIX}/\${MPC_TARGET_SUBPREFIX}/bin"
export LDFLAGS
EOF
		;;
	esac
else
#for the target
	if test ! -d "${MPC_RPREFIX}/${MPC_TARGET_SUBPREFIX}/${MPC_TARGET_SUBPREFIX}/"; then
		mkdir -p "${MPC_RPREFIX}/${MPC_TARGET_SUBPREFIX}/${MPC_TARGET_SUBPREFIX}/"
	fi
	
	if test -f "${MPC_RPREFIX}/${MPC_TARGET_SUBPREFIX}/${MPC_TARGET_SUBPREFIX}/.target_options"; then
		rm "${MPC_RPREFIX}/${MPC_TARGET_SUBPREFIX}/${MPC_TARGET_SUBPREFIX}/.target_options"
		touch "${MPC_RPREFIX}/${MPC_TARGET_SUBPREFIX}/${MPC_TARGET_SUBPREFIX}/.target_options"
	else
		touch "${MPC_RPREFIX}/${MPC_TARGET_SUBPREFIX}/${MPC_TARGET_SUBPREFIX}/.target_options"
	fi
	#for the target
	case "${SCTK_ARCH}" in 
		x86_64)
cat <<EOF >> "${MPC_RPREFIX}/${MPC_TARGET_SUBPREFIX}/${MPC_TARGET_SUBPREFIX}/.target_options"
#!/bin/sh
SCTK_MIC=0
export SCTK_MIC
CC=\`\${MPC_RPREFIX}/\$MPC_SUBPREFIX}/bin/mpc_compiler_manager get c 1\`
export CC
addarg=no
CFLAGS="\`\${MPC_RPREFIX}/\${MPC_TARGET_SUBPREFIX}/\${MPC_TARGET_SUBPREFIX}/bin/mpc_cflags c\`"
export CFLAGS
LDFLAGS="\`\${MPC_RPREFIX}/\${MPC_TARGET_SUBPREFIX}/\${MPC_TARGET_SUBPREFIX}/bin/mpc_ldflags c\`"	
export LDFLAGS
EOF
		;;
		k1om)
cat <<EOF >> "${MPC_RPREFIX}/${MPC_TARGET_SUBPREFIX}/${MPC_TARGET_SUBPREFIX}/.target_options"
#!/bin/sh
SCTK_MIC=1
export SCTK_MIC
CC=icc
export CC
addarg=no
CFLAGS="\`\${MPC_RPREFIX}/\${MPC_TARGET_SUBPREFIX}/\${MPC_TARGET_SUBPREFIX}/bin/mpc_cflags c\` -mmic"
export CFLAGS
LDFLAGS="\`\${MPC_RPREFIX}/\${MPC_TARGET_SUBPREFIX}/\${MPC_TARGET_SUBPREFIX}/bin/mpc_ldflags c\` -mmic -B\${MPC_RPREFIX}/\${MPC_HOST_SUBPREFIX}/\${MPC_TARGET_SUBPREFIX}/bin"	
export LDFLAGS
EOF
		;;
	esac
fi

#
# Generate C compiler
#
sctk_echo "Preparing C Compiler: mpc_cc"
printf_compiler bin/mpc_cc c

#
# Generate C compiler (for global linking)
#
#begin_section Generate C Compiler: mpc_cc_global
#printf_compiler bin/mpc_cc_global c global
#end_section

#
# Generate C++ compiler
#
sctk_echo "Preparing C++ Compiler: mpc_cxx"
printf_compiler bin/mpc_cxx cxx

#
# Generate Fortran compiler
#
if test "$SCTK_FORTRAN" = "1" ; then 
	sctk_echo "Preparing Fortran Compiler: mpc_f77"
	printf_compiler bin/mpc_f77 fortran
fi

sctk_echo "Preparing deprecated compilers for backward compatibility"
#deprecated C wrappers
printf_deprecated_compiler bin/mpc_icc bin/mpc_cc icc
printf_deprecated_compiler bin/mpc_gcc bin/mpc_cc gcc
#deprecated C++ wrappers
printf_deprecated_compiler bin/mpc_icpc bin/mpc_cxx icpc
printf_deprecated_compiler bin/mpc_g++ bin/mpc_cxx g++
#deprecated F wrappers
printf_deprecated_compiler bin/mpc_ifort bin/mpc_f77 ifort
printf_deprecated_compiler bin/mpc_gfortran bin/mpc_f77 gfortran

for i in bin/mpc_icc bin/mpc_gcc  bin/mpc_icpc bin/mpc_g++ bin/mpc_ifort bin/mpc_gfortran bin/mpc_cc bin/mpc_cxx bin/mpc_f77; do
printf_noflags_compiler ${i}_noflags $i
done

for i in cc cxx f77 icc icpc ifort; do
	printf_mpi_compiler bin/mpi$i bin/mpc_$i
done

if test "$SCTK_CUDA" = "1"; then
	sctk_echo "Preparing NVIDIA Compiler: mpc_nvcc"
	printf_compiler bin/mpc_nvcc cxx "nvcc --compiler-bindir "
fi

########################################
########################################
##### MPC_MPI_COMPILER_WRAPPER #########
########################################
########################################

genMPIcompilwrapper()
{
	
TARGET_COMP=$1
	
cat <<EOF
#!/bin/sh

# This is the MPI class compiler proxy
# to the MPC one, just passes the arguments
# through however note that by default
# this compiler does not privatize
# you can export MPI_PRIV to do it from here
# or just use their mpc_* counterpart

# This variable is used to inform
# sub-commands that the MPI compil
# wrapper is invoking them
export FROM_MPI_COMPIL_WRAPPER=1

MPI_PRIV_ARG="-fnompc-privatize"

if test ! -z "\$MPI_PRIV"; then
	MPI_PRIV_ARG=""
else
	# This variables request the process based linking
	# adapting the mpc_cflags and mpc_ldflags accordingly
	export MPI_COMPIL_PROCESS_BASED=1
fi

# Now invoke the compiler
$TARGET_COMP \$MPI_PRIV_ARG \$@ 

EOF

}

mkdir -p ./bin/mpiwrapp/

genMPIcompilwrapper "mpc_cc" >  bin/mpiwrapp/mpicc
genMPIcompilwrapper "mpc_cxx" > bin/mpiwrapp/mpicxx
genMPIcompilwrapper "mpc_cxx" > bin/mpiwrapp/mpic++
genMPIcompilwrapper "mpc_f77" > bin/mpiwrapp/mpif77
genMPIcompilwrapper "mpc_f77" > bin/mpiwrapp/mpif90
genMPIcompilwrapper "mpc_f77" > bin/mpiwrapp/mpifc
