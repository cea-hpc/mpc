/* ############################# MPC License ############################## */
/* # Wed Nov 19 15:19:19 CET 2008                                         # */
/* # Copyright or (C) or Copr. Commissariat a l'Energie Atomique          # */
/* #                                                                      # */
/* # IDDN.FR.001.230040.000.S.P.2007.000.10000                            # */
/* # This file is part of the MPC Runtime.                                # */
/* #                                                                      # */
/* # This software is governed by the CeCILL-C license under French law   # */
/* # and abiding by the rules of distribution of free software.  You can  # */
/* # use, modify and/ or redistribute the software under the terms of     # */
/* # the CeCILL-C license as circulated by CEA, CNRS and INRIA at the     # */
/* # following URL http://www.cecill.info.                                # */
/* #                                                                      # */
/* # The fact that you are presently reading this means that you have     # */
/* # had knowledge of the CeCILL-C license and that you accept its        # */
/* # terms.                                                               # */
/* #                                                                      # */
/* # Authors:                                                             # */
/* #   - BESNARD Jean-Baptiste jbbesnard@paratools.fr                     # */
/* #                                                                      # */
/* ######################################################################## */

#include "mpit_internal.h"

#include "mpcmp.h"
#include "sctk_thread.h"
#include "sctk_debug.h"

#include <string.h>

/************************************************************************/
/* INTERNAL MPI_T Init and Finalize                                     */
/************************************************************************/

int mpc_MPI_T_init_thread( int required, int * provided )
{

}

int mpc_MPI_T_finalize( void )
{

}

/************************************************************************/
/* INTERNAL MPI_T Enum                                                  */
/************************************************************************/

/** This is the internal enum data-structure */

int MPC_T_enum_init( struct MPC_T_enum * en, char * name, int num_entries, char *names[], int *values)
{
	en->name = strdup( name );
	en->number_of_entries = num_entries;

	en->entry_names = sctk_calloc( num_entries, sizeof( char *) );

	assume( en->entry_names != NULL );

	en->entry_values = sctk_calloc( num_entries , sizeof(int )) ;

	assume( en->entry_values != NULL );

	int i;

	for (i = 0; i < num_entries; ++i)
	{
		en->entry_names[i] = strdup( names[i] );
	}

	if( values )
	{
		for (i = 0; i < num_entries; ++i)
		{
			en->entry_values[i] = values[i];
		}
	}

	return MPI_SUCCESS;
}

int MPC_T_enum_release( struct MPC_T_enum * en)
{
	free( en->name );
	en->name = NULL;

	int i;

	for (i = 0; i < en->number_of_entries; ++i) {
		free( en->entry_names[i]);
		en->entry_values[i] = -1;
	} 

	sctk_free( en->entry_names );
	en->entry_names = NULL;

	sctk_free( en->entry_values );
	en->entry_values = NULL;

	en->number_of_entries = -1;

	return MPI_SUCCESS;
}



int mpc_MPI_T_enum_get_info( MPI_T_enum enumtype, int * num, char * name, int * name_len )
{
	struct MPC_T_enum *menu = (struct MPC_T_enum * )enumtype;

	if( !num 
			|| !name
			|| !name_len )
	{
		return MPI_ERR_ARG;
	}

	*num = menu->number_of_entries;
	*((char **)name) = menu->name;
	*name_len = strlen( menu->name );

	return MPI_SUCCESS;
}

int mpc_MPI_T_enum_get_item( MPI_T_enum enumtype, int index, int * value, char * name, int * name_len )
{
	struct MPC_T_enum *menu = (struct MPC_T_enum * )enumtype;

	if( !value 
			||  !name
			||  !name_len )
	{
		return MPI_ERR_ARG;
	}

	if( menu->number_of_entries <= index )
	{
		return MPI_T_ERR_INVALID_ITEM;
	}

	*value = menu->entry_values[index];
	*((char **)name) = menu->entry_names[index];
	*name_len = strlen( *((char **)name) );

	return MPI_SUCCESS;
}

/************************************************************************/
/* INTERNAL MPI_T Control variables CVARS                               */
/************************************************************************/

/** This is where the CVARS (meta) are being stored */

static sctk_spinlock_t cvar_array_lock = 0;
static int cvar_array_initialized = 0;
static struct MPC_T_cvars_array __cvar_array;

/** NOTE : This function is generated by the config */
int MPI_T_cvar_fill_info_from_config()
{

}

int MPI_T_cvars_array_init()
{
	sctk_spinlock_lock( &cvar_array_lock );

	if( cvar_array_initialized == 0 )
	{
		cvar_array_initialized = 1;
	}
	else
	{
		sctk_spinlock_unlock( &cvar_array_lock );
		return 0;
	}

	__cvar_array.dyn_cvar_count = 0;
	__cvar_array.dyn_cvars = NULL;
	__cvar_array.lock = 0;

	MPI_T_cvar_fill_info_from_config();

	sctk_spinlock_unlock( &cvar_array_lock );
	return 0;
}

int MPI_T_cvars_array_release()
{
	sctk_spinlock_lock( &cvar_array_lock );

	if( cvar_array_initialized == 1 )
	{
		cvar_array_initialized = 0;
	}
	else
	{
		sctk_spinlock_unlock( &cvar_array_lock );
		return 0;
	}

	__cvar_array.dyn_cvar_count = 0;
	sctk_free( __cvar_array.dyn_cvars );
	__cvar_array.dyn_cvars = NULL;

	sctk_spinlock_unlock( &cvar_array_lock );
	return 0;
}

struct MPC_T_cvar * MPI_T_cvars_array_get( MPC_T_cvar_t slot )
{
	if( MPI_T_cvars_array_init() )
	{
		return NULL;
	}

	if( slot < MPC_T_CVAR_COUNT )
	{
		return &__cvar_array.st_vars[ slot ];
	}
	else
	{
		struct MPC_T_cvar * cv = NULL;

		sctk_spinlock_lock( &cvar_array_lock );

		if( (slot - MPC_T_CVAR_COUNT)  < __cvar_array.dyn_cvar_count )
		{
			cv = &__cvar_array.dyn_cvars[slot - MPC_T_CVAR_COUNT];
		}

		sctk_spinlock_unlock( &cvar_array_lock );

		return cv;
	}
}

struct MPC_T_cvar * MPI_T_cvars_array_new( int * cvar_index )
{
	if(!cvar_index)
	{
		return NULL;
	}

	if( MPI_T_cvars_array_init() )
	{
		return NULL;
	}

	sctk_spinlock_lock( &cvar_array_lock );

	int my_index = __cvar_array.dyn_cvar_count;
	__cvar_array.dyn_cvar_count++;

	__cvar_array.dyn_cvars = sctk_realloc( __cvar_array.dyn_cvars,
			__cvar_array.dyn_cvar_count * sizeof( struct MPC_T_cvar ) );

	if( __cvar_array.dyn_cvars == NULL )
	{
		sctk_spinlock_unlock( &cvar_array_lock );
		return NULL;
	}

	sctk_spinlock_unlock( &cvar_array_lock );

	*cvar_index = my_index;
	return &__cvar_array.dyn_cvars[my_index];
}

/** This is how to manipulate CVARS */

int MPC_T_cvar_register_on_slot( int event_key,
		char * name,
		MPC_T_verbosity verbosity, 
		MPI_Datatype datatype,
		struct MPC_T_enum * enumtype ,
		char * desc, 
		MPC_T_binding bind, 
		MPC_T_cvar_scope scope )
{
	struct MPC_T_cvar * cv = NULL;

	if( event_key < MPC_T_CVAR_COUNT )
	{
		cv = MPI_T_cvars_array_get( event_key );
		assume( cv != NULL );
	}
	else
	{
		return -1;
	}

	cv->index = event_key;
	cv->name = strdup( name );
	cv->verbosity = verbosity;
	cv->datatype = datatype;
	memcpy( &cv->enumtype , enumtype, sizeof( struct MPC_T_enum) );
	cv->desc = strdup( desc );
	cv->bind = bind;
	cv->scope = scope;

	return 0;
}


int MPC_T_cvar_register( char * name,
		MPC_T_verbosity verbosity, 
		MPI_Datatype datatype,
		struct MPC_T_enum * enumtype ,
		char * desc, 
		MPC_T_binding bind, 
		MPC_T_cvar_scope scope )
{
	int my_index = -1;
	struct MPC_T_cvar * cv =  MPI_T_cvars_array_new( &my_index );

	assume( cv != NULL );

	cv->index = my_index;
	cv->name = strdup( name );
	cv->verbosity = verbosity;
	cv->datatype = datatype;
	memcpy( &cv->enumtype , enumtype, sizeof( struct MPC_T_enum) );
	cv->desc = strdup( desc );
	cv->bind = bind;
	cv->scope = scope;

	return 0;
}

/** This is the MPI Inteface */

int mpc_MPI_T_cvar_get_num( int *num_cvar )
{
	int ret = 0;

	sctk_spinlock_lock( &cvar_array_lock );
	ret = __cvar_array.dyn_cvar_count + MPC_T_CVAR_COUNT;
	sctk_spinlock_unlock( &cvar_array_lock );

	return ret;
}

int mpc_MPI_T_cvar_get_info( int cvar_index,
		char * name,
		int * name_len,
		int * verbosity, 
		MPI_Datatype *datatype,
		MPI_T_enum * enumtype,
		char * desc,
		int * desc_len, 
		int * bind, 
		int * scope )
{
	struct MPC_T_cvar *cvar =  MPI_T_cvars_array_get( cvar_index );

	if( !cvar )
	{
		return MPI_T_ERR_INVALID_INDEX;
	}

	*((char **)name) = cvar->name;
	*name_len = strlen( cvar->name );
	*verbosity = (int)cvar->verbosity;
	*datatype = cvar->datatype;
	*enumtype = (MPI_T_enum)&cvar->enumtype;
	*((char **)desc) = cvar->desc;
	*desc_len = strlen( cvar->desc );
	*bind = (int)cvar->bind;
	*scope = (int)cvar->scope;

	return MPI_SUCCESS;
}


int mpc_MPI_T_cvar_get_index( const char * name, int * cvar_index )
{
	int num_cvar;
	mpc_MPI_T_cvar_get_num( &num_cvar );

	int found = 0;
	int i;

	for (i = 0; i < num_cvar; ++i)
	{
		struct MPC_T_cvar *cvar =  MPI_T_cvars_array_get( i );

		if( !strcmp( cvar->name, name ) )
		{
			*cvar_index = i;
			found = 1;
			break;
		}
	}

	return found?MPI_SUCCESS:MPI_T_ERR_INVALID_INDEX;
}


/************************************************************************/
/* INTERNAL MPI_T Control variables CVARS HANDLES                       */
/************************************************************************/

int mpc_MPI_T_cvar_handle_alloc( int cvar_index , void * obj_handle, MPI_T_cvar_handle *handle, int * count )
{

}

int mpc_MPI_T_cvar_handle_free( MPI_T_cvar_handle * handle )
{

}

/************************************************************************/
/* INTERNAL MPI_T Control variables CVARS ACCESS                        */
/************************************************************************/

int mpc_MPI_T_cvar_read( MPI_T_cvar_handle handle, void * buff )
{

}

int mpc_MPI_T_cvar_write( MPI_T_cvar_handle handle, const void * buff )
{

}

/************************************************************************/
/* INTERNAL MPI_T Performance variables PVARS                           */
/************************************************************************/

/** This is the PVAR storage */

static struct MPC_T_pvars_array __pvar_array;
static int pvar_array_initialized = 0;
static sctk_spinlock_t pvar_array_lock = 0;

int MPI_T_pvar_fill_info_from_config()
{

}

int MPI_T_pvars_array_init()
{
	sctk_spinlock_lock( &pvar_array_lock );

	if( pvar_array_initialized == 0 )
	{
		pvar_array_initialized = 1;
	}
	else
	{
		sctk_spinlock_unlock( &pvar_array_lock );
		return 0;
	}

	__pvar_array.dyn_pvar_count = 0;
	__pvar_array.dyn_pvars = NULL;
	__pvar_array.lock = 0;

	MPI_T_pvar_fill_info_from_config();

	sctk_spinlock_unlock( &pvar_array_lock );
	return 0;

}

/** Release the CVAR array storage (done once)
 * @return Non-zero on error
 */
int MPI_T_pvars_array_release()
{
	sctk_spinlock_lock( &pvar_array_lock );

	if( pvar_array_initialized == 1 )
	{
		pvar_array_initialized = 0;
	}
	else
	{
		sctk_spinlock_unlock( &pvar_array_lock );
		return 0;
	}

	__pvar_array.dyn_pvar_count = 0;
	sctk_free( __pvar_array.dyn_pvars );
	__pvar_array.dyn_pvars = NULL;

	sctk_spinlock_unlock( &pvar_array_lock );
	return 0;
}

struct MPC_T_pvar * MPI_T_pvars_array_get( int slot )
{
	if( MPI_T_pvars_array_init() )
	{
		return NULL;
	}

	if( slot < MPC_T_PVAR_COUNT )
	{
		return &__pvar_array.st_pvar[ slot ];
	}
	else
	{
		struct MPC_T_pvar * pv = NULL;

		sctk_spinlock_lock( &pvar_array_lock );

		if( (slot - MPC_T_PVAR_COUNT)  < __pvar_array.dyn_pvar_count )
		{
			pv = &__pvar_array.dyn_pvars[slot - MPC_T_PVAR_COUNT];
		}

		sctk_spinlock_unlock( &pvar_array_lock );

		return pv;
	}

	return NULL;
}

struct MPC_T_pvar * MPI_T_pvars_array_new( int * pvar_index )
{
	if(!pvar_index)
	{
		return NULL;
	}

	if( MPI_T_pvars_array_init() )
	{
		return NULL;
	}

	sctk_spinlock_lock( &pvar_array_lock );

	int my_index = __pvar_array.dyn_pvar_count;
	__pvar_array.dyn_pvar_count++;

	__pvar_array.dyn_pvars = sctk_realloc( __pvar_array.dyn_pvars,
			__pvar_array.dyn_pvar_count * sizeof( struct MPC_T_pvar ) );

	if( __pvar_array.dyn_pvars == NULL )
	{
		sctk_spinlock_unlock( &pvar_array_lock );
		return NULL;
	}

	sctk_spinlock_unlock( &pvar_array_lock );

	*pvar_index = my_index;
	return &__pvar_array.dyn_pvars[my_index];

}

/** This is how to manipulate PVARS */

int mpc_MPI_T_pvars_array_register_on_slot(    int pvar_index,
		char *name,
		MPC_T_verbosity verbosity,
		MPC_T_pvar_class var_class,
		MPI_Datatype datatype,
		MPI_T_enum enumtype,
		char * desc,
		MPC_T_binding bind,
		int readonly,
		int continuous,
		int atomic )
{
	struct MPC_T_pvar * pv = NULL;

	if( pvar_index < MPC_T_CVAR_COUNT )
	{
		pv = MPI_T_pvars_array_get( pvar_index );
		assume( pv != NULL );
	}
	else
	{
		return -1;
	}

	pv->pvar_index = pvar_index;
	pv->name = strdup( name );
	pv->verbosity = verbosity;
	pv->pvar_class = var_class;
	pv->datatype = datatype;
	pv->enumtype = enumtype;
	pv->desc = strdup( desc );
	pv->bind = bind;
	pv->readonly = readonly;
	pv->continuous = continuous;
	pv->atomic = atomic;

	return 0;


}

int mpc_MPI_T_pvars_array_register( char *name,
		MPC_T_verbosity verbosity,
		MPC_T_pvar_class var_class,
		MPI_Datatype datatype,
		MPI_T_enum enumtype,
		char * desc,
		MPC_T_binding bind,
		int readonly,
		int continuous,
		int atomic )
{
	int my_index = -1;
	struct MPC_T_pvar * pv =  MPI_T_pvars_array_new( &my_index );

	assume( pv != NULL );

	pv->pvar_index = my_index;
	pv->name = strdup( name );
	pv->verbosity = verbosity;
	pv->pvar_class = var_class;
	pv->datatype = datatype;
	pv->enumtype = enumtype;
	pv->desc = strdup( desc );
	pv->bind = bind;
	pv->readonly = readonly;
	pv->continuous = continuous;
	pv->atomic = atomic;

	return 0;
}

/** This is the MPI interface */

int mpc_MPI_T_pvar_get_num( int * num_pvar )
{
	int ret = 0;

	sctk_spinlock_lock( &pvar_array_lock );
	ret = __pvar_array.dyn_pvar_count + MPC_T_PVAR_COUNT;
	sctk_spinlock_unlock( &pvar_array_lock );

	return ret;
}

int mpc_MPI_T_pvar_get_info( int pvar_index,
		char *name,
		int * name_len,
		int * verbosity,
		int * var_class,
		MPI_Datatype * datatype,
		MPI_T_enum * enumtype,
		char * desc,
		int * desc_len,
		int * bind,
		int * readonly,
		int * continuous,
		int * atomic )
{
	struct MPC_T_pvar * pv = MPI_T_pvars_array_get( pvar_index );

	if( !pv )
	{
		return MPI_T_ERR_INVALID_INDEX;
	}

	*((char **) name ) = pv->name;
	*name_len = strlen( pv->name );
	*verbosity = (int)pv->verbosity;
	*var_class = (int)pv->pvar_class;
	*datatype = pv->datatype;
	*enumtype = pv->enumtype;
	*((char **) desc ) = pv->desc;
	*desc_len = strlen( pv->desc );
	*bind = pv->bind;
	*readonly = pv->readonly;
	*continuous = pv->continuous;
	*atomic = pv->atomic;

	return MPI_SUCCESS;
}


int mpc_MPI_T_pvar_get_index( char * name , int * pvar_class, int * pvar_index )
{
	int num_pvar;
	mpc_MPI_T_pvar_get_num( &num_pvar );

	int found = 0;
	int i;

	for (i = 0; i < num_pvar; ++i)
	{
		struct MPC_T_pvar *pvar =  MPI_T_pvars_array_get( i );

		if( !strcmp( pvar->name, name ) )
		{
			*pvar_index = i;
			*pvar_class = pvar->pvar_class;
			found = 1;
			break;
		}
	}

	return found?MPI_SUCCESS:MPI_T_ERR_INVALID_INDEX;
}

/************************************************************************/
/* INTERNAL MPI_T Performance variables PVARS SESSIONS                  */
/************************************************************************/

int mpc_MPI_T_pvar_session_create( MPI_T_pvar_session * session )
{

}

int mpc_MPI_T_pvar_session_free( MPI_T_pvar_session * session )
{


}

/************************************************************************/
/* INTERNAL MPI_T Performance variables PVARS Handle Allocation         */
/************************************************************************/

int mpc_MPI_T_pvar_handle_alloc( MPI_T_pvar_session session,
		int pvar_index,
		void * obj_handle,
		MPI_T_pvar_handle * handle, 
		int * count )
{



}


int mpc_MPI_T_pvar_handle_free( MPI_T_pvar_handle * handle )
{


}

/************************************************************************/
/* INTERNAL MPI_T Performance variables PVARS Start and Stop            */
/************************************************************************/

int mpc_MPI_T_pvar_start( MPI_T_pvar_session session, MPI_T_pvar_handle handle )
{


}

int mpc_MPI_T_pvar_stop( MPI_T_pvar_session session, MPI_T_pvar_handle handle )
{

}

/************************************************************************/
/* INTERNAL MPI_T Performance variables PVARS Read and Write            */
/************************************************************************/

int mpc_MPI_T_pvar_read( MPI_T_pvar_session session, MPI_T_pvar_handle handle, void * buff )
{

}

int mpc_MPI_T_pvar_readreset( MPI_T_pvar_session session, MPI_T_pvar_handle handle, void * buff )
{

}

int mpc_MPI_T_pvar_write( MPI_T_pvar_session session, MPI_T_pvar_handle handle, const void * buff )
{

}

int mpc_MPI_T_pvar_reset( MPI_T_pvar_session session, MPI_T_pvar_handle handle )
{

}

/************************************************************************/
/* INTERNAL MPI_T variables categorization                              */
/************************************************************************/

int mpc_MPI_T_category_get_num( int * num_cat )
{


}

int mpc_MPI_T_category_get_info( int cat_index, 
		char * name, 
		int * name_len, 
		char * desc, 
		int * desc_len,
		int * num_cvars, 
		int * num_pvars,
		int * num_categories)
{


}

int mpc_MPI_T_category_get_index( char * name, int * cat_index )
{

}

int mpc_MPI_T_category_get_cvars( int cat_index, int len, int indices[])
{

}

int mpc_MPI_T_category_get_pvars( int cat_index, int len, int indices[])
{

}

int mpc_MPI_T_category_get_categories( int cat_index, int len, int indices[])
{


}

int mpc_MPI_T_category_changed( int * stamp )
{


}


